### [测试金字塔实战](https://martinfowler.com/articles/practical-test-pyramid.html#SociableAndSolitary)

> [The Practical Test Pyramid](https://martinfowler.com/articles/practical-test-pyramid.html#SociableAndSolitary)

“测试金字塔”是一个比喻，它告诉我们要把软件测试按照不同粒度来分组。它也给出了在这些分组中每个组应该有多少测试的看法。虽然测试金字塔的概念已经存在了一段时间，但一些团队仍然很难正确将它投入实践。本文重新审视“测试金字塔”最初的概念，并展示如何将其付诸实践。它展示了你应该在金字塔的不同层次上寻找何种类型的测试，并给出了如何实现这些测试的实例。

> The "Test Pyramid" is a metaphor that tells us to group software tests into buckets of different granularity. It also gives an idea of how many tests we should have in each of these groups. Although the concept of the Test Pyramid has been around for a while, teams still struggle to put it into practice properly. This article revisits the original concept of the Test Pyramid and shows how you can put this into practice. It shows which kinds of tests you should be looking for in the different levels of the pyramid and gives practical examples on how these can be implemented.

2018年2月26日

> 26 February 2018

作者：Ham Vocke

> Ham Vocke

Ham是德国ThoughtWorks的一名软件开发和咨询师。由于厌倦了在凌晨3点手动部署软件，他开始持续交付实践，加紧自动化步伐，并着手帮助团队高效可靠地交付高质量软件。这样他就可以把省出来的时间用在别的有趣的事情上了。

> Ham is a software developer and consultant at ThoughtWorks in Germany. Being tired of deploying software manually at 3 a.m., he added continuous delivery and diligent automation to his toolbox and set out to help teams deliver high-quality software reliably and efficiently. He makes up for the time gained by annoying people with his antics.

###### 目录
测试自动化的重要性

测试金字塔

我们用到的工具和库

应用例子

- 功能

- 整体架构

- 内部架构

单元测试

- 什么是单元？

- 社交和独处

- Mocking and Stubbing

- 测试什么？

- 测试架构

- 实现一个单元测试

集成测试

- 数据库集成

- REST API 集成

- 几个独立服务的集成

- JSON的解析和撰写

契约测试

- 消费者测试(我们团队)

- 提供者测试(其他团队)

- 提供者测试(我们团队)

UI测试

端到端测试

- 用户界面端到端测试

- REST API 端到端测试

验收测试 - 你的功能可以正常使用吗？

探索性测试

对测试术语的误解

把测试放到部署流水线

避免重复测试

对写测试的建议

总结

有时候我真的想测试私有方法

> ##### Contents

> The Importance of (Test) Automation

> The Test Pyramid

> Tools and Libraries We'll Look at

> The Sample Application

> - Functionality

> - High-level Structure

> - Internal Architecture

> Unit tests

> - What's a Unit?

> - Sociable and Solitary

> - Mocking and Stubbing

> - What to Test?

> - Test Structure

> - Implementing a Unit Test

> Integration Tests

> - Database Integration

> - Integration With Separate Services

> Contract Tests

> - Consumer Test (our team)

> - Provider Test (the other team)

> - Provider Test (our team)

> UI Tests

> End-to-End Tests

> - User Interface End-to-End Test

> - REST API End-to-End Test

> Acceptance Tests — Do Your Features Work Correctly?

> Exploratory Testing

> The Confusion About Testing Terminology

> Putting Tests Into Your Deployment Pipeline

> Avoid Test Duplication

> Writing Clean Test Code

> Conclusion

> ##### Sidebars

> But I Really Need to Test This Private Method

> Specialised Test Helpers

![](https://martinfowler.com/articles/practical-test-pyramid/teaser.png)

准备上生产环境的软件在上生产之前需要进行测试。随着软件开发行业的成熟，软件测试方法也日趋成熟。开发团队正在逐渐自动化大部分的测试，而不是依赖于大量的测试人员来进行手工测试。通过自动化测试，开发团队可以几秒钟就知道他们的软件是否被破坏，而不是几天后才知道。

> Production-ready software requires testing before it goes into production. As the discipline of software development matured, software testing approaches have matured too. Instead of having myriads of manual software testers development teams have moved towards automating the biggest portion of their testing efforts. Automating your test efforts allows teams to know whether their software is broken in a matter of seconds and minutes instead of days and weeks.

自动化测试极大地缩短了反馈周期，这与敏捷开发实践、持续集成、DevOps 文化等是一脉相承的。拥有高效的软件测试方法，可以让你的团队快速而自信地前行。

> The drastically shortened feedback loop fuelled by automated tests goes hand in hand with agile development practices, continuous delivery and DevOps culture. Having an effective software testing approach allows your team to move fast and confidently.

本文将探讨一个具备高响应力的、可靠并且可维护的测试组合应该如何构建，这与你具体构建的是一个微服务架构、移动应用程序或者物联网生态系统都无关。此外，我们还将详细介绍如何写出高效且可读的自动化测试。

> This article explores what a well-rounded test portfolio should look like to be responsive, reliable and maintainable - regardless of whether you're building a microservices architecture, mobile apps or IoT ecosystems. We'll also get into the details of building effective and readable automated tests.

## （测试）自动化的重要性

软件已经成为我们日常生活中的一个重要组成部分。早期它仅仅用于提高企业的效率，但如今它的作用远不止如此。如今许多公司都想方设法成为一流的数字化公司。作为用户，我们每天使用的软件越来越多。创新的车轮正越转越快。

> Software has become an essential part of the world we live in. It has outgrown its early sole purpose of making businesses more efficient. Today companies try to find ways to become first-class digital companies. As users everyone of us interacts with an ever-increasing amount of software every day. The wheels of innovation are turning faster.

如果你想跟上时代的步伐，你必须研究如何在不牺牲质量的情况下更快地交付你的软件。持续交付——一种高度自动化的、确保你可以随时将软件发布到生产环境中的实践——正能帮你达到这个目的。它也可以通过构建流水线自动测试你的软件并将其部署到测试和生产环境中。

> If you want to keep pace you'll have to look into ways to deliver your software faster without sacrificing its quality. Continuous delivery, a practice where you automatically ensure that your software can be released into production any time, can help you with that. With continuous delivery you use a build pipeline to automatically test your software and deploy it to your testing and production environments.

软件的数量正以前所未有的速度增长，如果还是手动进行构建、测试和部署，很快就会变得不可能了——除非你想把所有的时间都用来进行手动重复的工作，而不是用来开发可工作的软件。将一切自动化——从构建到测试，从部署到基础架构——是你唯一的出路。

> Building, testing and deploying an ever-increasing amount of software manually soon becomes impossible — unless you want to spend all your time with manual, repetitive work instead of delivering working software. Automating everything — from build to tests, deployment and infrastructure — is your only way forward.

![图1](https://martinfowler.com/articles/practical-test-pyramid/buildPipeline.png)

*图1：使用构建流水线来自动并可靠地将你的软件部署到生产环境*

> Figure 1: Use build pipelines to automatically and reliably get your software into production

传统的软件测试过于依赖手工操作：你首先将应用程序部署到测试环境后，然后执行一些黑盒测试，例如，通过点击用户界面来查看一切是否工作如常。通常这些测试将由文档指定，以确保测试人员每次测试的内容是一致的。

> Traditionally software testing was overly manual work done by deploying your application to a test environment and then performing some black-box style testing e.g. by clicking through your user interface to see if anything's broken. Often these tests would be specified by test scripts to ensure the testers would do consistent checking.

很明显，手动测试所有更改非常耗时、重复而且繁琐。重复很无趣，无趣就容易犯错，这样还没测到周末结束你就会想找下一份工作了。

> It's obvious that testing all changes manually is time-consuming, repetitive and tedious. Repetitive is boring, boring leads to mistakes and makes you look for a different job by the end of the week.

幸运的是，重复性劳动还是有药可治的：自动化。

> Luckily there's a remedy for repetitive tasks: automation.

自动化繁琐重复的测试将给软件开发人员的生活带来重大改变。自动化这些测试后，你就不需要再一味遵循测试文档点点点以确保软件是否仍正常工作。自动化这些测试，你可以充满自信地修改你的代码。如果你曾试过在没有适当自动化测试的情况下进行大规模的重构，那你应该知道这种体验多么恐怖。你怎么知道你有否意外地破坏了某些功能呢？显然，你需要将所有的测试用例手动点一遍。不过老实说，你真的享受这个过程吗？你想象一下，如果你对代码做了大规模改动后惬意地喝了一口咖啡，喝完咖啡后你能马上得知你的改动有没有破坏原有功能。这样的开发体验是不是听起来就让人舒服多了？

> Automating your repetitive tests can be a big game changer in your life as a software developer. Automate these tests and you no longer have to mindlessly follow click protocols in order to check if your software still works correctly. Automate your tests and you can change your codebase without batting an eye. If you've ever tried doing a large-scale refactoring without a proper test suite I bet you know what a terrifying experience this can be. How would you know if you accidentally broke stuff along the way? Well, you click through all your manual test cases, that's how. But let's be honest: do you really enjoy that? How about making even large-scale changes and knowing whether you broke stuff within seconds while taking a nice sip of coffee? Sounds more enjoyable if you ask me.

## 测试金字塔

如果你真的想为你的软件构建自动化测试，你必须知道一个关键的概念：测试金字塔。Mike Cohn在他的着作《Succeeding with Agile》一书中提出了这个概念。这个比喻非常形象，它让你一眼就知道测试是需要分层的。它还告诉你每一层需要写多少测试。

> If you want to get serious about automated tests for your software there is one key concept you should know about: the test pyramid. Mike Cohn came up with this concept in his book Succeeding with Agile. It's a great visual metaphor telling you to think about different layers of testing. It also tells you how much testing to do on each layer.

![图2](https://martinfowler.com/articles/practical-test-pyramid/testPyramid.png)

*图2：测试金字塔*

根据Mike Cohn的测试金字塔，你的测试组合应该由以下三层组成（自下往上分别是）：

- 单元测试
- 服务测试
- 用户界面测试

> Mike Cohn's original test pyramid consists of three layers that your test suite should consist of (bottom to top):

> - Unit Tests
> - Service Tests
> - User Interface Tests

不幸的是，如果你仔细思考就会发现，测试金字塔的概念有点太短了。有人认为，Mike Cohn的测试金字塔里的命名或某些概念不是最理想的。我也同意这一点。从当今的角度来看，测试金字塔似乎过于简单了，因此可能会产生误导。

> Unfortunately the concept of the test pyramid falls a little short if you take a closer look. Some argue that either the naming or some conceptual aspects of Mike Cohn's test pyramid are not ideal, and I have to agree. From a modern point of view the test pyramid seems overly simplistic and can therefore be misleading.

然而，由于其简洁性，在建立你自己的测试组合时，测试金字塔本身是一条很好的经验法则。你最好是记住Cohn测试金字塔中提到的两件事：

- 编写不同粒度的测试
- 层次越高，你写的测试应该越少

> Still, due to it's simplicity the essence of the test pyramid serves as a good rule of thumb when it comes to establishing your own test suite. Your best bet is to remember two things from Cohn's original test pyramid:

> - Write tests with different granularity
> - The more high-level you get the fewer tests you should have

为了维持金字塔形状，一个健康、快速、可维护的测试组合应该是这样的：写许多小而快的单元测试。适当写一些更粗粒度的测试，写很少高层次的端到端测试。注意不要让你的测试变成[冰淇淋](https://www.thoughtworks.com/insights/blog/introducing-software-testing-cupcake-anti-pattern)那样子，这对维护来说将是一个噩梦，并且跑一遍也需要太多时间。

> Stick to the pyramid shape to come up with a healthy, fast and maintainable test suite: Write lots of small and fast unit tests. Write some more coarse-grained tests and very few high-level tests that test your application from end to end. Watch out that you don't end up with a test ice-cream cone that will be a nightmare to maintain and takes way too long to run.

不要太拘泥于Cohn测试金字塔中各层次的名字。事实上，它们可能相当具有误导性：服务测试是一个难以掌握的术语（Cohn本人说他观察到[很多开发人员完全忽略了这一层](https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid)）。在单页应用框架（如react，angular，ember.js等）的时代，UI测试显然不必位于金字塔的最高层，你完全能够用这些框架对UI进行单元测试。

> Don't become too attached to the names of the individual layers in Cohn's test pyramid. In fact they can be quite misleading: service test is a term that is hard to grasp (Cohn himself talks about the observation that a lot of developers completely ignore this layer). In the days of single page application frameworks like react, angular, ember.js and others it becomes apparent that UI tests don't have to be on the highest level of your pyramid - you're perfectly able to unit test your UI in all of these frameworks.

考虑到原始名称的缺点，只要在你的代码库和团队讨论中达成一致，你完全可以为测试层次提供其他名称。

> Given the shortcomings of the original names it's totally okay to come up with other names for your test layers, as long as you keep it consistent within your codebase and your team's discussions.

## 我们将使用的工具和库

- [JUnit](http://junit.org/junit5/): 测试执行库
- [Mockito](http://site.mockito.org/): 仿造(mock)依赖
- [Wiremock](http://wiremock.org/): 隔离外部服务
- MockMVC: 编写 HTTP 集成测试（需要补充链接）
- [Pact](https://docs.pact.io/): 用于编写消费者驱动的契约测试
- [Selenium](http://docs.seleniumhq.org/): 用于编写用户界面驱动的端到端测试
- [REST-assured](https://github.com/rest-assured/rest-assured): 用于编写REST API驱动的端到端测试

> - JUnit: our test runner
> - Mockito: for mocking dependencies
> - Wiremock: for stubbing out external services
> - MockMVC: for writing HTTP integration tests
> - Pact: for writing CDC tests
> - Selenium: for writing UI-driven end-to-end tests
> - REST-assured: for writing REST API-driven end-to-end tests


## 示例应用

我已经写好了一个[简单的微服务应用](https://github.com/hamvocke/spring-testing)，其中涵盖了测试金字塔各种层次的测试。

> I've written a simple microservice including a test suite with tests for the different layers of the test pyramid.

示例应用体现了一个典型的微服务的特点。它提供了一个REST接口，与数据库进行通信并从第三方REST服务中获取信息。它是使用Spring Boot实现的，即使你之前从未使用过Spring Boot，它也简单到应该可以理解。

> The sample application shows traits of a typical microservice. It provides a REST interface, talks to a database and fetches information from a third-party REST service. It's implemented in Spring Boot and should be understandable even if you've never worked with Spring Boot before.

请下载Github上的代码。Readme里写了你在计算机上运行应用程序及其自动化测试所需的说明。

> Make sure to check out the code on Github. The readme contains instructions you need to run the application and its automated tests on your machine.

##### 功能

应用的功能十分简单。它提供了三个REST接口：

- ```GET /hello```	总是返回"Hello World"
	 ```GET /hello/{lastname}```	根据lastname来查询人，如果查到了结果将返回"Hello {Firstname} {Lastname}"
	 ```GET /weather```	返回现在德国汉堡的天气情况

> The application's functionality is simple. It provides a REST interface with three endpoints:

> - ```GET /hello```	Returns "Hello World". Always.
> 	 ```GET /hello/{lastname}```	Looks up the person with the provided last name. If the person is known, returns "Hello {Firstname} {Lastname}".
> 	 ```GET /weather```	Returns the current weather conditions for Hamburg, Germany.

##### 高层架构

从高层次来看，这个系统的结构是这样：

> On a high-level the system has the following structure:

![图3](https://martinfowler.com/articles/practical-test-pyramid/testService.png)

*图3：我们微服务系统的高层架构*

我们的微服务提供了一个可以通过HTTP调用的REST接口。对于某些接口，服务将从数据库获取信息。在其他情况下，服务将通过HTTP调用外部[天气API](https://darksky.net/forecast/40.7127,-74.0059/us12/en)来获取并显示当前天气状况。

> Our microservice provides a REST interface that can be called via HTTP. For some endpoints the service will fetch information from a database. In other cases the service will call an external weather API via HTTP to fetch and display current weather conditions.

##### 内部架构

在内部，Spring Service有一个典型的Spring架构：

> Internally, the Spring Service has a Spring-typical architecture:

![图4](https://martinfowler.com/articles/practical-test-pyramid/testArchitecture.png)

*图4：我们微服务的内部架构*

- ```Controller``` 提供REST接口，处理HTTP请求和响应
- ```Repository``` 和数据库打交道，关注数据在持久化存储里的读写操作
- ```Client``` 和别的API交互，在我们的应用里它会通过HTTPS从darksky.net获取天气情况
- ```Domain``` 这是我们的[领域模型](https://en.wikipedia.org/wiki/Domain_model)，它包含了领域逻辑（相对来说，在我们的示例中不甚重要）

> - ```Controller``` classes provide REST endpoints and deal with HTTP requests and responses
> - ```Repository``` classes interface with the database and take care of writing and reading data to/from persistent storage
> - ```Client``` classes talk to other APIs, in our case it fetches JSON via HTTPS from the darksky.net weather API
> - ```Domain``` classes capture our [domain model](https://en.wikipedia.org/wiki/Domain_model) including the domain logic (which, to be fair, is quite trivial in our case).

有经验的Spring开发人员可能会注意到这里缺失了一个常用的层次：受[Domain-Driven Design](https://en.wikipedia.org/wiki/Domain-driven_design)的启发，很多开发人员通常会构建一个由服务类组成的服务层。我决定不在这个应用中包含服务层。原因之一是我们的应用程序很简单，服务层只会成为一个不必要的中间层。另一个是我认为人们过度使用服务层。我经常遇到在服务类中写了全部业务逻辑的代码库。领域模型仅仅成为数据层，而不是行为（[贫血域模型](https://en.wikipedia.org/wiki/Anemic_domain_model)）。对于每一个稍有复杂度的应用来说，这浪费了很多让代码保持结构良好且易于测试的优秀方案，并且没能充分利用面向对象的威力。

> Experienced Spring developers might notice that a frequently used layer is missing here: Inspired by Domain-Driven Design a lot of developers build a service layer consisting of service classes. I decided not to include a service layer in this application. One reason is that our application is simple enough, a service layer would have been an unnecessary level of indirection. The other one is that I think people overdo it with service layers. I often encounter codebases where the entire business logic is captured within service classes. The domain model becomes merely a layer for data, not for behaviour (an Anemic Domain Model). For every non-trivial application this wastes a lot of potential to keep your code well-structured and testable and does not fully utilise the power of object orientation.

我们的repositories非常简单，它提供简单的CRUD功能。为了保持代码简单，我使用了Spring Data。 Spring Data为我们提供了一个简单而通用的CRUD实现，我们可以直接使用而不需再造轮子。它还负责为我们的测试启动一个内存数据库，而不是像生产中一样使用真正的PostgreSQL数据库。

> Our repositories are straightforward and provide simple CRUD functionality. To keep the code simple I used Spring Data. Spring Data gives us a simple and generic CRUD repository implementation that we can use instead of rolling our own. It also takes care of spinning up an in-memory database for our tests instead of using a real PostgreSQL database as it would in production.

看看代码库，熟悉一下内部结构。这将有助于我们的下一步：测试我们的应用！

> Take a look at the codebase and make yourself familiar with the internal structure. It will be useful for our next step: Testing the application!

## 单元测试

单元测试将成为你测试组合的基石。你的单元测试保证了代码库里的某个单元（被测试的主体）能按照预期那样工作。单元测试在你的测试组合里测试的范围是最窄的。它的数量在测试组合中应该远远多于其他类型的测试。

> The foundation of your test suite will be made up of unit tests. Your unit tests make sure that a certain unit (your subject under test) of your codebase works as intended. Unit tests have the narrowest scope of all the tests in your test suite. The number of unit tests in your test suite will largely outnumber any other type of test.

![图5](https://martinfowler.com/articles/practical-test-pyramid/unitTest.png)

*图5：一个用测试替身隔绝了外部依赖的典型单元测试*

#### 一个单元指的是什么？

如果你去问三个人同样的问题：“单元”在单元测试的上下文中意味着什么，你很可能会获得四种非常相似的答案。某种程度上讲，对“单元”的定义取决于你自己，因此这个问题没有标准答案也是可以接受的。

> If you ask three different people what "unit" means in the context of unit tests, you'll probably receive four different, slightly nuanced answers. To a certain extent it's a matter of your own definition and it's okay to have no canonical answer.

如果你正在使用函数式语言，一个单元最有可能指的是一个函数。你的单元测试将使用不同的参数调用这个函数，并断言它返回了期待的结果。在面向对象语言里，下至一个方法，上至一个类都可以是一个单元（从一个单一的方法到一整个的类都可以是一个单元）。

> If you're working in a functional language a unit will most likely be a single function. Your unit tests will call a function with different parameters and ensure that it returns the expected values. In an object-oriented language a unit can range from a single method to an entire class.

#### 群居和独居

一些人主张，应该将被测试主体下的所有合作者（比如在测试里被你的类调用的其他类）都使用mock或者stub替换掉，这样可以建立完美的隔离，避免副作用和复杂的测试准备。而有些人主张，只有那些执行起来很慢或者有较大副作用的合作者（比如读写数据库或者发送网络请求的类）才应该被mock或者stub掉。

> Some argue that all collaborators (e.g. other classes that are called by your class under test) of your subject under test should be substituted with mocks or stubs to come up with perfect isolation and to avoid side-effects and a complicated test setup. Others argue that only collaborators that are slow or have bigger side effects (e.g. classes that access databases or make network calls) should be stubbed or mocked.

[偶尔](https://martinfowler.com/bliki/UnitTest.html)有人会把stub掉所有依赖的测试称为独居单元测试，把和依赖有交互的测试成为群居单元测试（Jay Fields的[《Working Effectively with Unit Tests》](https://leanpub.com/wewut)这本书里创造了这些概念）。如果有空你可以继续深究下去，读一读不同思想流派各自的[利弊](https://martinfowler.com/articles/mocksArentStubs.html)在哪。

> [Occasionally](https://martinfowler.com/bliki/UnitTest.html) people label these two sorts of tests as solitary unit tests for tests that stub all collaborators and sociable unit tests for tests that allow talking to real collaborators (Jay Fields' [Working Effectively with Unit Tests](https://leanpub.com/wewut) coined these terms). If you have some spare time you can go down the rabbit hole and [read more about the pros and cons](https://martinfowler.com/articles/mocksArentStubs.html) of the different schools of thought.

说到底，决定采用群居方式还是独居方式的单元测试其实并不重要。写自动化测试才是重要的。就我自己而言，我发现我自己经常两种方式都用。如果使用真正的合作者很麻烦，我就会用mock或者stub。如果我觉得引用真正的合作者能让我对测试更有信心，我会仅仅stub掉service最外层的依赖。

> At the end of the day it's not important to decide if you go for solitary or sociable unit tests. Writing automated tests is what's important. Personally, I find myself using both approaches all the time. If it becomes awkward to use real collaborators I will use mocks and stubs generously. If I feel like involving the real collaborator gives me more confidence in a test I'll only stub the outermost parts of my service.

#### Mocking and Stubbing

Mocks和Stubs是两种不一样的测试替身（测试替身还不止这两种）。很多人会混用Mock和Stub这两个概念。我认为，准确的用词会好点，并且最好能将它们各自的特性谙熟于心。你可以使用测试替身来替换掉真实的对象，给它一个可以更方便地测试的实现。

> Mocks and Stubs are two different kinds of Test Doubles (there are more than these two). A lot of people use the terms Mock and Stub interchangeably. I think it's good to be precise and keep their specific properties in mind. You can use test doubles to replace objects you'd use in production with an implementation that helps you with testing.

换句话说，这意味着你是用一个假的实现来代替真的那个（例如，一个类，一个模块或者一个函数）。这个假的实现外表和行为和真的很像（都能响应同样的方法调用），只不过真实的响应内容是你在单元测试开始前就定义好的。

> In plain words it means that you replace a real thing (e.g. a class, module or function) with a fake version of that thing. The fake version looks and acts like the real thing (answers to the same method calls) but answers with canned responses that you define yourself at the beginning of your unit test.

并不是在单元测试时我们才使用测试替身。还有很多精妙的测试替身能以非常可控的方式来模拟整个系统的功能。然而，在单元测试里使用mocks和stubs的概率会更高（取决于你是喜欢群居风格还是独居风格的开发者），这主要是因为现代语言和库使得构建mocks和stubs变得更加简单了。

> Using test doubles is not specific to unit testing. More elaborate test doubles can be used to simulate entire parts of your system in a controlled way. However, in unit testing you're most likely to encounter a lot of mocks and stubs (depending of whether you're the sociable or solitary kind of developer), simply because lots of modern languages and libraries make it easy and comfortable to set up mocks and stubs.

不管你的技术选型是怎么样的，不管是你使用语言的标准库还是一些流行的第三方库，现在都有优雅的方式来构建mocks。甚至你可以在测试里自己拼凑出一个具有相同参数类型的仿造类，模块或者函数来代替真正的东西。

> 不管你的技术选型是怎么样的，一般来说，编程语言的标准库或一些比较有名的三方库都会提供一些优雅的方式来帮你构建 mocks。即使需要自己编写 mock 对象，也只是写一个假类/模块/函数的事，只需要让它与真实的合作者有相同的签名，并设置到你的测试中去即可。

> Regardless of your technology choice, there's a good chance that either your language's standard library or some popular third-party library will provide you with elegant ways to set up mocks. And even writing your own mocks from scratch is only a matter of writing a fake class/module/function with the same signature as the real one and setting up the fake in your test.

你的单元测试跑起来应该非常快。在一般的机器上跑完数千个单元测试应该只需要几分钟。为了得到快速的单元测试，你应该独立地测试代码库的每一小块，并避免进行真实的数据库操作、文件系统操作，或者发送真实的 HTTP 请求（使用 mocks 和 stubs 来隔离这一部分）。

> Your unit tests will run very fast. On a decent machine you can expect to run thousands of unit tests within a few minutes. Test small pieces of your codebase in isolation and avoid hitting databases, the filesystem or firing HTTP queries (by using mocks and stubs for these parts) to keep your tests fast.

一旦你掌握了写单元测试的诀窍，你写起来就能越来越顺畅。Stub掉外部依赖，准备一些输入数据，调用被测试的主体，然后检查返回值是不是你所期待的。看看[测试驱动开发](https://en.wikipedia.org/wiki/Test-driven_development)，让单元测试指引你的开发；如果使用得当，测试驱动开发将帮你进入一个非常顺畅的工作流，它能帮你创造出一个良好且可维护的设计，顺便还能送你一套全面且自动化的测试。当然，测试驱动开发并不是银弹。但是建议你尝试一下，看看它是否适合你。

> Once you got a hang of writing unit tests you will become more and more fluent in writing them. Stub out external collaborators, set up some input data, call your subject under test and check that the returned value is what you expected. Look into [Test-Driven Development](https://en.wikipedia.org/wiki/Test-driven_development) and let your unit tests guide your development; if applied correctly it can help you get into a great flow and come up with a good and maintainable design while automatically producing a comprehensive and fully automated test suite. Still, it's no silver bullet. Go ahead, give it a real chance and see if it feels right for you.

#### 应该测试什么？

单元测试有个好处，就是你可以为所有的产品代码类写单元测试，而不需要管它们的功能如何，或者它们在内部结构中属于哪个层次。你可以对 controller 进行单元测试，也可以用同样的方式对 repository、领域类或者文件读写类进行单元测试。良好的开端，从坚持**一个实现类就有一个测试类**的法则开始。

> The good thing about unit tests is that you can write them for all your production code classes, regardless of their functionality or which layer in your internal structure they belong to. You can unit tests controllers just like you can unit test repositories, domain classes or file readers. Simply stick to the **one test class per production class** rule of thumb and you're off to a good start.

一个单元测试类至少应该测试**这个类的公共接口**。私有方法不能直接测试的原因是你不能从测试类直接调用它们。受保护的和包私有的方法可以被测试类直接调用（如果测试类和生产代码类的包结构是一样的），但是测试这些方法可能就太过了。

> A unit test class should at least **test the public interface of the class**. Private methods can't be tested anyways since you simply can't call them from a different test class. Protected or package-private are accessible from a test class (given the package structure of your test class is the same as with the production class) but testing these methods could already go too far.

编写单元测试有一条细则：它们应该保证你代码所有的路径都被测试到（包括正常路径和边缘路径）。同时它们不应该和代码的实现有太紧密的耦合。

> There's a fine line when it comes to writing unit tests: They should ensure that all your non-trivial code paths are tested (including happy path and edge cases). At the same time they shouldn't be tied to your implementation too closely.

为什么这样说呢？

> Why's that?

测试如果与产品代码耦合太紧，很快就会令人讨厌。当你重构代码时（快速回顾一下：重构意味着改变代码的内部结构而不改变其对外的行为）你的单元测试就会挂掉。

> Tests that are too close to the production code quickly become annoying. As soon as you refactor your production code (quick recap: refactoring means changing the internal structure of your code without changing the externally visible behaviour) your unit tests will break.

这样的话你就损失了单元测试的一大好处：充当代码变更的保护网。你很快就会厌烦这些愚蠢的测试，而不会感到它能带来好处，因为你每次重构测试就会挂掉，带来更多的工作量。不过说起来这些愚蠢的测试又是谁把它写成这样的呢？

> This way you lose one big benefit of unit tests: acting as a safety net for code changes. You rather become fed up with those stupid tests failing every time you refactor, causing more work than being helpful; and whose idea was this stupid testing stuff anyways?

那么正确的做法是什么？是不要在你的单元测试里耦合实现代码的内部结构。要测试可观测的行为。你应该这样思考：

> What do you do instead? Don't reflect your internal code structure within your unit tests. Test for observable behaviour instead. Think about

*如果我的输入是x和y，输出会是z吗？*

> *if I enter values x and y, will the result be z?*

而不是这样：

> instead of

*如果我的输入是x和y，那么这个方法会先调用A类，然后调用B类，接着输出A类和B类返回值相加的结果吗？*

> *if I enter x and y, will the method call class A first, then call class B and then return the result of class A plus the result of class B?*

私有方法应该被视为实现细节。这就是为什么你不应该有去测试他们的冲动。

> Private methods should generally be considered an implementation detail. That's why you shouldn't even have the urge to test them.

我经常听单元测试（或者TDD）的反对者说，编写单元测试是无意义的工作，因为为了获得一个高的测试覆盖率，你必须测试所有的方法。他们经常引用这样的场景：一个过于激昂的团队领导强硬地让他们为getter、setter及其他所有琐碎的代码施加测试，以达到100%的测试覆盖率。

> I often hear opponents of unit testing (or TDD) arguing that writing unit tests becomes pointless work where you have to test all your methods in order to come up with a high test coverage. They often cite scenarios where an overly eager team lead forced them to write unit tests for getters and setters and all other sorts of trivial code in order to come up with 100% test coverage.

这就大错特错啦。

> There's so much wrong with that.

确实你应该测试公共接口。但是更重要的是，**不要去测试微不足道的代码**。别担心，[Kent Beck说这样是OK的](https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/)。你不会因为测试getter，setter抑或是其他简单的实现（比如没有任何条件逻辑的实现）而得到任何价值。把时间省出来，你就能多参加一个会了，万岁！

> Yes, you should test the public interface. More importantly, however, you **don't test trivial code**. Don't worry, [Kent Beck said it's ok](https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/). You won't gain anything from testing simple getters or setters or other trivial implementations (e.g. without any conditional logic). Save the time, that's one more meeting you can attend, hooray!

#### 测试结构

一个好的测试结构（不局限于单元测试）是这样的：

> A good structure for all your tests (this is not limited to unit tests) is this one:

1. 准备测试数据

> 1.Set up the test data

2. 调用被测方法

> 2.Call your method under test

3. 断言返回的是你期待的结果

> 3.Assert that the expected results are returned

这里有个口诀可以帮你记住这种结构：[“Arrange，Act，Assert”](https://xp123.com/articles/3a-arrange-act-assert/)。另一个口诀则是从BDD获取的灵感。就是[“given”，“when”，“then”](https://martinfowler.com/bliki/GivenWhenThen.html)三件套，given说的是准备数据，when指的是调用方法，then则是断言。

> There's a nice mnemonic to remember this structure: ["Arrange, Act, Assert"](https://xp123.com/articles/3a-arrange-act-assert/). Another one that you can use takes inspiration from BDD. It's the ["given", "when", "then"](https://martinfowler.com/bliki/GivenWhenThen.html) triad, where given reflects the setup, when the method call and then the assertion part.

这种模式也可以应用于其他更高层次的测试。在任何情况下，它们都能让你的测试保持一致，易于阅读。除此之外，使用这种结构写出来的测试，往往更简短，更具表达力。

> This pattern can be applied to other, more high-level tests as well. In every case they ensure that your tests remain easy and consistent to read. On top of that tests written with this structure in mind tend to be shorter and more expressive.

#### 实现一个单元测试

知道了测什么、如何组织单元测试后，我们终于可以看一个真正的例子了。

> Now that we know what to test and how to structure our unit tests we can finally see a real example.

让我们来看一个简化版的ExampleController类：

> Let's take a simplified version of the ExampleController class:

```java
@RestController
public class ExampleController {

    private final PersonRepository personRepo;

    @Autowired
    public ExampleController(final PersonRepository personRepo) {
        this.personRepo = personRepo;
    }

    @GetMapping("/hello/{lastName}")
    public String hello(@PathVariable final String lastName) {
        Optional<Person> foundPerson = personRepo.findByLastName(lastName);

        return foundPerson
                .map(person -> String.format("Hello %s %s!",
                        person.getFirstName(),
                        person.getLastName()))
                .orElse(String.format("Who is this '%s' you're talking about?",
                        lastName));
    }
}
```

一个针对`hello(lastname)`方法的单元测试可能是这样的：

> A unit test for the hello(lastname) method could look like this:

```java
public class ExampleControllerTest {

    private ExampleController subject;

    @Mock
    private PersonRepository personRepo;

    @Before
    public void setUp() throws Exception {
        initMocks(this);
        subject = new ExampleController(personRepo);
    }

    @Test
    public void shouldReturnFullNameOfAPerson() throws Exception {
        Person peter = new Person("Peter", "Pan");
        given(personRepo.findByLastName("Pan"))
            .willReturn(Optional.of(peter));

        String greeting = subject.hello("Pan");

        assertThat(greeting, is("Hello Peter Pan!"));
    }

    @Test
    public void shouldTellIfPersonIsUnknown() throws Exception {
        given(personRepo.findByLastName(anyString()))
            .willReturn(Optional.empty());

        String greeting = subject.hello("Pan");

        assertThat(greeting, is("Who is this 'Pan' you're talking about?"));
    }
}
```

我们写单元测试用的是[JUnit](http://junit.org/)，Java实际意义上的标准测试框架。我们使用[Mockito](http://site.mockito.org/)来stub掉真正的`PersonRepository`类。这个stub允许我们在测试里重新定义PersonRepository被调用后产生的响应。stub能让我们的测试更简单，更可预测，更容易组织测试数据。

> We're writing the unit tests using [JUnit](http://junit.org/), the de-facto standard testing framework for Java. We use [Mockito](http://site.mockito.org/) to replace the real PersonRepository class with a stub for our test. This stub allows us to define canned responses the stubbed method should return in this test. Stubbing makes our test more simple, predictable and allows us to easily setup test data.

依照Arrange，Act，Assert的结构，我们写了两个单元测试 - 一个是正常的场景，另一个是找不到搜索人的场景。首先，正常场景创建了一个新的person对象，然后告诉mock类，当你接受到以“Pan”作为参数的调用时，返回这个person对象。这个测试接着调用了被测试方法。最后它断言返回值是等于期待结果的。

> Following the arrange, act, assert structure, we write two unit tests - a positive case and a case where the searched person cannot be found. The first, positive test case creates a new person object and tells the mocked repository to return this object when it's called with "Pan" as the value for the lastName parameter. The test then goes on to call the method that should be tested. Finally it asserts that the response is equal to the expected response.

第二个测试和第一个类似，但它测试的是被测方法找不到对应人名时的场景。

> The second test works similarly but tests the scenario where the tested method does not find a person for the given parameter.

### To be continue...


