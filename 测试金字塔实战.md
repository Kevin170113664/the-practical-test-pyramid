### [测试金字塔实战](https://martinfowler.com/articles/practical-test-pyramid.html)

> [The Practical Test Pyramid](https://martinfowler.com/articles/practical-test-pyramid.html)

“测试金字塔”是一个比喻，它告诉我们要把软件测试按照不同粒度来分组。它也告诉我们每个组应该有多少测试。虽然测试金字塔的概念已经存在了一段时间，但一些团队仍然很难正确将它投入实践。本文重新审视“测试金字塔”最初的概念，并展示如何将其付诸实践。本文将告诉你应该在金字塔的不同层次上寻找何种类型的测试，如何实现这些测试。

> The "Test Pyramid" is a metaphor that tells us to group software tests into buckets of different granularity. It also gives an idea of how many tests we should have in each of these groups. Although the concept of the Test Pyramid has been around for a while, teams still struggle to put it into practice properly. This article revisits the original concept of the Test Pyramid and shows how you can put this into practice. It shows which kinds of tests you should be looking for in the different levels of the pyramid and gives practical examples on how these can be implemented.

2018年2月26日

> 26 February 2018

作者：Ham Vocke

> Ham Vocke

Ham是德国ThoughtWorks的一名软件开发和咨询师。由于厌倦了在凌晨3点手动部署软件，他开始持续交付实践，加紧自动化步伐，并着手帮助团队高效可靠地交付高质量软件。这样他就可以把省出来的时间用在别的有趣的事情上了。

> Ham is a software developer and consultant at ThoughtWorks in Germany. Being tired of deploying software manually at 3 a.m., he added continuous delivery and diligent automation to his toolbox and set out to help teams deliver high-quality software reliably and efficiently. He makes up for the time gained by annoying people with his antics.

###### 目录
测试自动化的重要性

测试金字塔

我们用到的工具和库

应用例子

- 功能

- 整体架构

- 内部架构

单元测试

- 什么是单元？

- 社交和独处

- Mocking and Stubbing

- 测试什么？

- 测试架构

- 实现一个单元测试

集成测试

- 数据库集成

- REST API 集成

- 几个独立服务的集成

- JSON的解析和撰写

契约测试

- 消费者测试(我们团队)

- 提供者测试(其他团队)

- 提供者测试(我们团队)

UI测试

端到端测试

- 用户界面端到端测试

- REST API 端到端测试

验收测试 - 你的功能在正常工作吗？

探索测试

测试术语误解

把测试放到部署流水线

避免测试重复

整洁测试代码

结论

> ##### Contents

> The Importance of (Test) Automation

> The Test Pyramid

> Tools and Libraries We'll Look at

> The Sample Application

> - Functionality

> - High-level Structure

> - Internal Architecture

> Unit tests

> - What's a Unit?

> - Sociable and Solitary

> - Mocking and Stubbing

> - What to Test?

> - Test Structure

> - Implementing a Unit Test

> Integration Tests

> - Database Integration

> - Integration With Separate Services

> Contract Tests

> - Consumer Test (our team)

> - Provider Test (the other team)

> - Provider Test (our team)

> UI Tests

> End-to-End Tests

> - User Interface End-to-End Test

> - REST API End-to-End Test

> Acceptance Tests — Do Your Features Work Correctly?

> Exploratory Testing

> The Confusion About Testing Terminology

> Putting Tests Into Your Deployment Pipeline

> Avoid Test Duplication

> Writing Clean Test Code

> Conclusion

> ##### Sidebars

> But I Really Need to Test This Private Method

> Specialised Test Helpers

![](https://martinfowler.com/articles/practical-test-pyramid/teaser.png)

准备上生产环境的软件在上生产之前需要进行测试。随着软件开发行业的成熟，软件测试方法也日趋成熟。开发团队正在逐渐自动化大部分的测试，以此取代大量测试人员手工测试。通过自动化测试，开发团队可以分分钟就知道他们的软件是否被破坏，而不是后知后觉几天后才知道。

> Production-ready software requires testing before it goes into production. As the discipline of software development matured, software testing approaches have matured too. Instead of having myriads of manual software testers development teams have moved towards automating the biggest portion of their testing efforts. Automating your test efforts allows teams to know whether their software is broken in a matter of seconds and minutes instead of days and weeks.

自动化测试极大地缩短了反馈周期，这与敏捷开发实践、持续集成、DevOps 文化等是一脉相承的。拥有高效的软件测试方法，可以让你的团队快速而自信地前行。

> The drastically shortened feedback loop fuelled by automated tests goes hand in hand with agile development practices, continuous delivery and DevOps culture. Having an effective software testing approach allows your team to move fast and confidently.

本文将探讨一个具备高响应力的、可靠并且可维护的测试组合应该如何构建，这与你具体构建的是一个微服务架构、移动应用程序或者物联网生态系统都无关。此外，我们还将详细介绍如何写出高效且可读的自动化测试。

> This article explores what a well-rounded test portfolio should look like to be responsive, reliable and maintainable - regardless of whether you're building a microservices architecture, mobile apps or IoT ecosystems. We'll also get into the details of building effective and readable automated tests.

## （测试）自动化的重要性

软件已经成为我们日常生活中的一个重要组成部分。早期它仅仅用于提高企业的效率，但如今它的作用远不止如此。如今许多公司都想方设法成为一流的数字化公司。作为用户，我们每天使用的软件越来越多。创新的车轮正加速向前滚动。

> Software has become an essential part of the world we live in. It has outgrown its early sole purpose of making businesses more efficient. Today companies try to find ways to become first-class digital companies. As users everyone of us interacts with an ever-increasing amount of software every day. The wheels of innovation are turning faster.

如果你想跟上时代的步伐，你必须研究如何在不牺牲质量的情况下更快地交付你的软件。持续交付——一种高度自动化的、确保你可以随时将软件发布到生产环境中的实践——正能帮你达到这个目的。它通过构建流水线自动测试你的软件，自动其部署到测试和生产环境中。

> If you want to keep pace you'll have to look into ways to deliver your software faster without sacrificing its quality. Continuous delivery, a practice where you automatically ensure that your software can be released into production any time, can help you with that. With continuous delivery you use a build pipeline to automatically test your software and deploy it to your testing and production environments.

软件的数量正以前所未有的速度增长，手动进行构建、测试和部署，很快就会变得不可能——除非你想把所有的时间都用来进行手动重复的工作，而不是用来开发可工作的软件。将一切自动化，从构建到测试，从部署到基础架构，这是你唯一的出路。

> Building, testing and deploying an ever-increasing amount of software manually soon becomes impossible — unless you want to spend all your time with manual, repetitive work instead of delivering working software. Automating everything — from build to tests, deployment and infrastructure — is your only way forward.

![图1](https://martinfowler.com/articles/practical-test-pyramid/buildPipeline.png)

*图1：使用构建流水线来自动并可靠地将你的软件部署到生产环境*

> Figure 1: Use build pipelines to automatically and reliably get your software into production

传统的软件测试过于依赖手工操作：首先将应用程序部署到测试环境，然后执行一些黑盒测试，例如，通过点击用户界面来查看一切是否工作如常。通常这些测试将由文档指定，以确保测试人员每次测试的内容是一致的。

> Traditionally software testing was overly manual work done by deploying your application to a test environment and then performing some black-box style testing e.g. by clicking through your user interface to see if anything's broken. Often these tests would be specified by test scripts to ensure the testers would do consistent checking.

很明显，手动测试所有更改非常耗时、重复而且繁琐。重复很无趣，无趣就容易犯错，这样子还没测到这周工作结束你就会想找下一份工作了。

> It's obvious that testing all changes manually is time-consuming, repetitive and tedious. Repetitive is boring, boring leads to mistakes and makes you look for a different job by the end of the week.

幸运的是，重复性劳动还是有药可治的：自动化。

> Luckily there's a remedy for repetitive tasks: automation.

自动化繁琐重复的测试将给软件开发人员的生活带来重大改变。自动化这些测试后，你就不需要再一味遵循测试文档点点点以确保软件是否仍正常工作。自动化这些测试，你可以充满自信地修改你的代码。如果你曾试过在没有适当自动化测试的情况下进行大规模重构，那你应该知道这种体验多么恐怖。你怎么知道你是否意外地破坏了某些功能呢？显然，你需要将所有的测试用例手动点一遍。不过老实说，你真的享受这个过程吗？你想象一下，如果你对代码做了大规模改动后惬意地喝了一口咖啡，喝完咖啡后就能马上得知你的改动有没有破坏原有功能。这样的开发体验是不是听起来就让人舒服多了？

> Automating your repetitive tests can be a big game changer in your life as a software developer. Automate these tests and you no longer have to mindlessly follow click protocols in order to check if your software still works correctly. Automate your tests and you can change your codebase without batting an eye. If you've ever tried doing a large-scale refactoring without a proper test suite I bet you know what a terrifying experience this can be. How would you know if you accidentally broke stuff along the way? Well, you click through all your manual test cases, that's how. But let's be honest: do you really enjoy that? How about making even large-scale changes and knowing whether you broke stuff within seconds while taking a nice sip of coffee? Sounds more enjoyable if you ask me.

## 测试金字塔

如果你真的想为你的软件构建自动化测试，你必须知道一个关键的概念：测试金字塔。Mike Cohn在他的着作《Succeeding with Agile》一书中提出了这个概念。这个比喻非常形象，它让你一眼就知道测试是需要分层的。它还告诉你每一层需要写多少测试。

> If you want to get serious about automated tests for your software there is one key concept you should know about: the test pyramid. Mike Cohn came up with this concept in his book Succeeding with Agile. It's a great visual metaphor telling you to think about different layers of testing. It also tells you how much testing to do on each layer.

![图2](https://martinfowler.com/articles/practical-test-pyramid/testPyramid.png)

*图2：测试金字塔*

根据Mike Cohn的测试金字塔，你的测试组合应该由以下三层组成（自下往上分别是）：

- 单元测试
- 服务测试
- 用户界面测试

> Mike Cohn's original test pyramid consists of three layers that your test suite should consist of (bottom to top):

> - Unit Tests
> - Service Tests
> - User Interface Tests

不幸的是，如果你仔细思考就会发现，测试金字塔的概念有点太短了。有人认为，Mike Cohn的测试金字塔里的命名或某些概念不是最理想的。我也同意这一点。从当今的角度来看，测试金字塔似乎过于简单了，因此可能会产生误导。

> Unfortunately the concept of the test pyramid falls a little short if you take a closer look. Some argue that either the naming or some conceptual aspects of Mike Cohn's test pyramid are not ideal, and I have to agree. From a modern point of view the test pyramid seems overly simplistic and can therefore be misleading.

然而，由于其简洁性，在建立你自己的测试组合时，测试金字塔本身是一条很好的经验法则。你最好记住Cohn测试金字塔中提到的两件事：

- 编写不同粒度的测试
- 层次越高，你写的测试应该越少

> Still, due to it's simplicity the essence of the test pyramid serves as a good rule of thumb when it comes to establishing your own test suite. Your best bet is to remember two things from Cohn's original test pyramid:

> - Write tests with different granularity
> - The more high-level you get the fewer tests you should have

为了维持金字塔形状，一个健康、快速、可维护的测试组合应该是这样的：写许多小而快的单元测试。适当写一些更粗粒度的测试，写很少高层次的端到端测试。注意不要让你的测试变成[冰淇淋](https://www.thoughtworks.com/insights/blog/introducing-software-testing-cupcake-anti-pattern)那样子，这对维护来说将是一个噩梦，并且跑一遍也需要太多时间。

> Stick to the pyramid shape to come up with a healthy, fast and maintainable test suite: Write lots of small and fast unit tests. Write some more coarse-grained tests and very few high-level tests that test your application from end to end. Watch out that you don't end up with a test ice-cream cone that will be a nightmare to maintain and takes way too long to run.

不要太拘泥于Cohn测试金字塔中各层次的名字。事实上，它们可能相当具有误导性：服务测试是一个难以掌握的术语（Cohn本人说他观察到[很多开发人员完全忽略了这一层](https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid)）。在单页应用框架（如react，angular，ember.js等）的时代，UI测试显然不必位于金字塔的最高层，你完全能够用这些框架对UI进行单元测试。

> Don't become too attached to the names of the individual layers in Cohn's test pyramid. In fact they can be quite misleading: service test is a term that is hard to grasp (Cohn himself talks about the observation that a lot of developers completely ignore this layer). In the days of single page application frameworks like react, angular, ember.js and others it becomes apparent that UI tests don't have to be on the highest level of your pyramid - you're perfectly able to unit test your UI in all of these frameworks.

考虑到原始名称的缺点，只要在你的代码库和团队讨论中达成一致，你完全可以为测试层次提供其他名称。

> Given the shortcomings of the original names it's totally okay to come up with other names for your test layers, as long as you keep it consistent within your codebase and your team's discussions.

## 我们将使用的工具和库

- [JUnit](http://junit.org/junit5/): 测试执行库
- [Mockito](http://site.mockito.org/): 仿造(mock)依赖
- [Wiremock](http://wiremock.org/): 隔离外部服务
- [Pact](https://docs.pact.io/): 用于编写消费者驱动的契约测试
- [Selenium](http://docs.seleniumhq.org/): 用于编写用户界面驱动的端到端测试
- [REST-assured](https://github.com/rest-assured/rest-assured): 用于编写REST API驱动的端到端测试

> - JUnit: our test runner
> - Mockito: for mocking dependencies
> - Wiremock: for stubbing out external services
> - Pact: for writing CDC tests
> - Selenium: for writing UI-driven end-to-end tests
> - REST-assured: for writing REST API-driven end-to-end tests


## 示例应用

我已经写好了一个[简单的微服务应用](https://github.com/hamvocke/spring-testing)，其中涵盖了测试金字塔各种层次的测试。

> I've written a simple microservice including a test suite with tests for the different layers of the test pyramid.

示例应用体现了一个典型的微服务的特点。它提供了一个REST接口，与数据库进行通信并从第三方REST服务中获取信息。它是使用Spring Boot实现的，即使你之前从未使用过Spring Boot，它也简单到应该让你很容易理解。

> The sample application shows traits of a typical microservice. It provides a REST interface, talks to a database and fetches information from a third-party REST service. It's implemented in Spring Boot and should be understandable even if you've never worked with Spring Boot before.

请下载Github上的代码。Readme里写了你在计算机上运行应用程序及其自动化测试所需的说明。

> Make sure to check out the code on Github. The readme contains instructions you need to run the application and its automated tests on your machine.

##### 功能

应用的功能十分简单。它提供了三个REST接口：

- ```GET /hello```	总是返回"Hello World"
	 ```GET /hello/{lastname}```	根据lastname来查询人，如果查到了结果将返回"Hello {Firstname} {Lastname}"
	 ```GET /weather```	返回现在德国汉堡的天气情况

> The application's functionality is simple. It provides a REST interface with three endpoints:

> - ```GET /hello```	Returns "Hello World". Always.
> 	 ```GET /hello/{lastname}```	Looks up the person with the provided last name. If the person is known, returns "Hello {Firstname} {Lastname}".
> 	 ```GET /weather```	Returns the current weather conditions for Hamburg, Germany.

##### 高层架构

从高层次来看，这个系统的结构是这样：

> On a high-level the system has the following structure:

![图3](https://martinfowler.com/articles/practical-test-pyramid/testService.png)

*图3：我们微服务系统的高层架构*

我们的微服务提供了一个可以通过HTTP调用的REST接口。对于某些接口，服务将从数据库获取信息。在其他情况下，服务将通过HTTP调用外部[天气API](https://darksky.net/forecast/40.7127,-74.0059/us12/en)来获取并显示当前天气状况。

> Our microservice provides a REST interface that can be called via HTTP. For some endpoints the service will fetch information from a database. In other cases the service will call an external weather API via HTTP to fetch and display current weather conditions.

##### 内部架构

在内部，Spring Service有一个典型的Spring架构：

> Internally, the Spring Service has a Spring-typical architecture:

![图4](https://martinfowler.com/articles/practical-test-pyramid/testArchitecture.png)

*图4：我们微服务的内部架构*

- ```Controller``` 提供REST接口，处理HTTP请求和响应
- ```Repository``` 和数据库打交道，关注数据在持久化存储里的读写操作
- ```Client``` 和别的API交互，在我们的应用里它会通过HTTPS从darksky.net获取天气情况
- ```Domain``` 这是我们的[领域模型](https://en.wikipedia.org/wiki/Domain_model)，它包含了领域逻辑（相对来说，在我们的示例中不甚重要）

> - ```Controller``` classes provide REST endpoints and deal with HTTP requests and responses
> - ```Repository``` classes interface with the database and take care of writing and reading data to/from persistent storage
> - ```Client``` classes talk to other APIs, in our case it fetches JSON via HTTPS from the darksky.net weather API
> - ```Domain``` classes capture our [domain model](https://en.wikipedia.org/wiki/Domain_model) including the domain logic (which, to be fair, is quite trivial in our case).

有经验的Spring开发人员可能会注意到这里缺失了一个常用的层次：受[Domain-Driven Design](https://en.wikipedia.org/wiki/Domain-driven_design)的启发，很多开发人员通常会构建一个由服务类组成的服务层。我决定不在这个应用中包含服务层。原因之一是我们的应用程序很简单，服务层只会成为一个不必要的中间层。另一个是我认为人们过度使用服务层。我经常遇到在服务类中写了全部业务逻辑的代码库。领域模型仅仅成为数据层，而不是行为（[贫血域模型](https://en.wikipedia.org/wiki/Anemic_domain_model)）。对于每一个稍有复杂度的应用来说，这浪费了很多让代码保持结构良好且易于测试的优秀方案，并且没能充分利用面向对象的威力。

> Experienced Spring developers might notice that a frequently used layer is missing here: Inspired by Domain-Driven Design a lot of developers build a service layer consisting of service classes. I decided not to include a service layer in this application. One reason is that our application is simple enough, a service layer would have been an unnecessary level of indirection. The other one is that I think people overdo it with service layers. I often encounter codebases where the entire business logic is captured within service classes. The domain model becomes merely a layer for data, not for behaviour (an Anemic Domain Model). For every non-trivial application this wastes a lot of potential to keep your code well-structured and testable and does not fully utilise the power of object orientation.

我们的repositories非常简单，它提供简单的CRUD功能。为了保持代码简单，我使用了Spring Data。 Spring Data为我们提供了一个简单而通用的CRUD实现，我们可以直接使用而不需再造轮子。它还负责为我们的测试启动一个内存数据库，而不是像生产中一样使用真正的PostgreSQL数据库。

> Our repositories are straightforward and provide simple CRUD functionality. To keep the code simple I used Spring Data. Spring Data gives us a simple and generic CRUD repository implementation that we can use instead of rolling our own. It also takes care of spinning up an in-memory database for our tests instead of using a real PostgreSQL database as it would in production.

看看代码库，熟悉一下内部结构。这将有助于我们的下一步：测试我们的应用！

> Take a look at the codebase and make yourself familiar with the internal structure. It will be useful for our next step: Testing the application!

## 单元测试

单元测试将成为你测试组合的基石。你的单元测试保证了代码库里的某个单元（被测试的主体）能按照预期那样工作。单元测试在你的测试组合里测试的范围是最窄的。它的数量在测试组合中应该远远多于其他类型的测试。

> The foundation of your test suite will be made up of unit tests. Your unit tests make sure that a certain unit (your subject under test) of your codebase works as intended. Unit tests have the narrowest scope of all the tests in your test suite. The number of unit tests in your test suite will largely outnumber any other type of test.

![图5](https://martinfowler.com/articles/practical-test-pyramid/unitTest.png)

*图5：一个用测试替身隔绝了外部依赖的典型单元测试*

#### 一个单元指的是什么？

如果你去问三个人同样的问题：“单元”在单元测试的上下文中意味着什么，你很可能会获得四种非常相似的答案。某种程度上讲，对“单元”的定义取决于你自己，因此这个问题没有标准答案。

> If you ask three different people what "unit" means in the context of unit tests, you'll probably receive four different, slightly nuanced answers. To a certain extent it's a matter of your own definition and it's okay to have no canonical answer.

如果你正在使用函数式语言，一个单元最有可能指的是一个函数。你的单元测试将使用不同的参数调用这个函数，并断言它返回了期待的结果。在面向对象语言里，下至一个方法，上至一个类都可以是一个单元（从一个单一的方法到一整个的类都可以是一个单元）。

> If you're working in a functional language a unit will most likely be a single function. Your unit tests will call a function with different parameters and ensure that it returns the expected values. In an object-oriented language a unit can range from a single method to an entire class.

#### 群居和独居

一些人主张，应该将被测试主体下的所有合作者（比如在测试里被你的类调用的其他类）都使用mock或者stub替换掉，这样可以建立完美的隔离，避免副作用和复杂的测试准备。而有些人主张，只有那些执行起来很慢或者有较大副作用的合作者（比如读写数据库或者发送网络请求的类）才应该被mock或者stub掉。

> Some argue that all collaborators (e.g. other classes that are called by your class under test) of your subject under test should be substituted with mocks or stubs to come up with perfect isolation and to avoid side-effects and a complicated test setup. Others argue that only collaborators that are slow or have bigger side effects (e.g. classes that access databases or make network calls) should be stubbed or mocked.

[偶尔](https://martinfowler.com/bliki/UnitTest.html)有人会把stub掉所有依赖的测试称为独居单元测试，把和依赖有交互的测试成为群居单元测试（Jay Fields的[《Working Effectively with Unit Tests》](https://leanpub.com/wewut)这本书里创造了这些概念）。如果有空你可以继续深究下去，读一读不同思想流派各自的[利弊](https://martinfowler.com/articles/mocksArentStubs.html)在哪。

> [Occasionally](https://martinfowler.com/bliki/UnitTest.html) people label these two sorts of tests as solitary unit tests for tests that stub all collaborators and sociable unit tests for tests that allow talking to real collaborators (Jay Fields' [Working Effectively with Unit Tests](https://leanpub.com/wewut) coined these terms). If you have some spare time you can go down the rabbit hole and [read more about the pros and cons](https://martinfowler.com/articles/mocksArentStubs.html) of the different schools of thought.

说到底，决定采用群居方式还是独居方式的单元测试其实并不重要。写自动化测试才是重要的。就我自己而言，我发现我自己经常两种方式都用。如果使用真正的合作者很麻烦，我就会用mock或者stub。如果我觉得引用真正的合作者能让我对测试更有信心，我会仅仅stub掉service最外层的依赖。

> At the end of the day it's not important to decide if you go for solitary or sociable unit tests. Writing automated tests is what's important. Personally, I find myself using both approaches all the time. If it becomes awkward to use real collaborators I will use mocks and stubs generously. If I feel like involving the real collaborator gives me more confidence in a test I'll only stub the outermost parts of my service.

#### Mocking and Stubbing

Mocks和Stubs是两种不一样的测试替身（测试替身还不止这两种）。很多人会混用Mock和Stub这两个概念。我认为，准确的用词会好点，并且最好能将它们各自的特性谙熟于心。你可以使用测试替身来替换掉真实的对象，给它一个可以更方便测试的实现。

> Mocks and Stubs are two different kinds of Test Doubles (there are more than these two). A lot of people use the terms Mock and Stub interchangeably. I think it's good to be precise and keep their specific properties in mind. You can use test doubles to replace objects you'd use in production with an implementation that helps you with testing.

换句话说，这意味着你是用一个假的实现来代替真的那个（例如，一个类，一个模块或者一个函数）。这个假的实现外表和行为和真的很像（都能响应同样的方法调用），只不过真实的响应内容是你在单元测试开始前就定义好的。

> In plain words it means that you replace a real thing (e.g. a class, module or function) with a fake version of that thing. The fake version looks and acts like the real thing (answers to the same method calls) but answers with canned responses that you define yourself at the beginning of your unit test.

并不是在单元测试时我们才使用测试替身。还有很多精妙的测试替身能以非常可控的方式来模拟整个系统的功能。然而，在单元测试里使用mocks和stubs的概率会更高（取决于你是喜欢群居风格还是独居风格的开发者），这主要是因为现代语言和库使得构建mocks和stubs变得更加简单了。

> Using test doubles is not specific to unit testing. More elaborate test doubles can be used to simulate entire parts of your system in a controlled way. However, in unit testing you're most likely to encounter a lot of mocks and stubs (depending of whether you're the sociable or solitary kind of developer), simply because lots of modern languages and libraries make it easy and comfortable to set up mocks and stubs.

不管你的技术选型是怎么样的，一般来说，编程语言的标准库或一些比较有名的三方库都会提供一些优雅的方式来帮你构建 mocks。即使需要自己编写 mock 对象，也只是写一个假类/模块/函数的事，只需要让它与真实的合作者有相同的签名，并设置到你的测试中去即可。

> Regardless of your technology choice, there's a good chance that either your language's standard library or some popular third-party library will provide you with elegant ways to set up mocks. And even writing your own mocks from scratch is only a matter of writing a fake class/module/function with the same signature as the real one and setting up the fake in your test.

你的单元测试跑起来应该非常快。在一般的机器上跑完数千个单元测试应该只需要几分钟。为了得到快速的单元测试，你应该独立地测试代码库的每一小块，并避免进行真实的数据库操作、文件系统操作，或者发送真实的 HTTP 请求（使用 mocks 和 stubs 来隔离这一部分）。

> Your unit tests will run very fast. On a decent machine you can expect to run thousands of unit tests within a few minutes. Test small pieces of your codebase in isolation and avoid hitting databases, the filesystem or firing HTTP queries (by using mocks and stubs for these parts) to keep your tests fast.

一旦你掌握了写单元测试的诀窍，你写起来就能越来越顺畅。Stub掉外部依赖，准备一些输入数据，调用被测试的主体，然后检查返回值是不是你所期待的。看看[测试驱动开发](https://en.wikipedia.org/wiki/Test-driven_development)，让单元测试指引你的开发；如果使用得当，测试驱动开发将帮你进入一个非常顺畅的工作流，它能帮你创造出一个良好且可维护的设计，顺便还能送你一套全面且自动化的测试。当然，测试驱动开发并不是银弹。但是建议你尝试一下，看看它是否适合你。

> Once you got a hang of writing unit tests you will become more and more fluent in writing them. Stub out external collaborators, set up some input data, call your subject under test and check that the returned value is what you expected. Look into [Test-Driven Development](https://en.wikipedia.org/wiki/Test-driven_development) and let your unit tests guide your development; if applied correctly it can help you get into a great flow and come up with a good and maintainable design while automatically producing a comprehensive and fully automated test suite. Still, it's no silver bullet. Go ahead, give it a real chance and see if it feels right for you.

#### 应该测试什么？

单元测试有个好处，就是你可以为所有的产品代码类写单元测试，而不需要管它们的功能如何，或者它们在内部结构中属于哪个层次。你可以对 controller 进行单元测试，也可以用同样的方式对 repository、领域类或者文件读写类进行单元测试。良好的开端，从坚持**一个实现类就有一个测试类**的法则开始。

> The good thing about unit tests is that you can write them for all your production code classes, regardless of their functionality or which layer in your internal structure they belong to. You can unit tests controllers just like you can unit test repositories, domain classes or file readers. Simply stick to the **one test class per production class** rule of thumb and you're off to a good start.

一个单元测试类至少应该测试**这个类的公共接口**。私有方法不能直接测试的原因是你不能从测试类直接调用它们。受保护的和包私有的方法可以被测试类直接调用（如果测试类和生产代码类的包结构是一样的），但是测试这些方法可能就太过了。

> A unit test class should at least **test the public interface of the class**. Private methods can't be tested anyways since you simply can't call them from a different test class. Protected or package-private are accessible from a test class (given the package structure of your test class is the same as with the production class) but testing these methods could already go too far.

编写单元测试有一条细则：它们应该保证你代码所有的路径都被测试到（包括正常路径和边缘路径）。同时它们不应该和代码的实现有太紧密的耦合。

> There's a fine line when it comes to writing unit tests: They should ensure that all your non-trivial code paths are tested (including happy path and edge cases). At the same time they shouldn't be tied to your implementation too closely.

为什么这样说呢？

> Why's that?

测试如果与产品代码耦合太紧，很快就会令人讨厌。当你重构代码时（快速回顾一下：重构意味着改变代码的内部结构而不改变其对外的行为）你的单元测试就会挂掉。

> Tests that are too close to the production code quickly become annoying. As soon as you refactor your production code (quick recap: refactoring means changing the internal structure of your code without changing the externally visible behaviour) your unit tests will break.

这样的话你就损失了单元测试的一大好处：充当代码变更的保护网。你很快就会厌烦这些愚蠢的测试，而不会感到它能带来好处，因为你每次重构测试就会挂掉，带来更多的工作量。不过说起来这些愚蠢的测试又是谁把它写成这样的呢？

> This way you lose one big benefit of unit tests: acting as a safety net for code changes. You rather become fed up with those stupid tests failing every time you refactor, causing more work than being helpful; and whose idea was this stupid testing stuff anyways?

那么正确的做法是什么？是不要在你的单元测试里耦合实现代码的内部结构。要测试可观测的行为。你应该这样思考：

> What do you do instead? Don't reflect your internal code structure within your unit tests. Test for observable behaviour instead. Think about

*如果我的输入是x和y，输出会是z吗？*

> *if I enter values x and y, will the result be z?*

而不是这样：

> instead of

*如果我的输入是x和y，那么这个方法会先调用A类，然后调用B类，接着输出A类和B类返回值相加的结果吗？*

> *if I enter x and y, will the method call class A first, then call class B and then return the result of class A plus the result of class B?*

私有方法应该被视为实现细节。这就是为什么你不应该有去测试他们的冲动。

> Private methods should generally be considered an implementation detail. That's why you shouldn't even have the urge to test them.

我经常听单元测试（或者TDD）的反对者说，编写单元测试是无意义的工作，因为为了获得一个高的测试覆盖率，你必须测试所有的方法。他们经常引用这样的场景：一个过于激昂的团队领导强硬地让他们为getter、setter及其他所有琐碎的代码施加测试，以达到100%的测试覆盖率。

> I often hear opponents of unit testing (or TDD) arguing that writing unit tests becomes pointless work where you have to test all your methods in order to come up with a high test coverage. They often cite scenarios where an overly eager team lead forced them to write unit tests for getters and setters and all other sorts of trivial code in order to come up with 100% test coverage.

这就大错特错啦。

> There's so much wrong with that.

确实你应该测试公共接口。但是更重要的是，**不要去测试微不足道的代码**。别担心，[Kent Beck说这样是OK的](https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/)。你不会因为测试getter，setter抑或是其他简单的实现（比如没有任何条件逻辑的实现）而得到任何价值。把时间省出来，你就能多参加一个会了，万岁！

> Yes, you should test the public interface. More importantly, however, you **don't test trivial code**. Don't worry, [Kent Beck said it's ok](https://stackoverflow.com/questions/153234/how-deep-are-your-unit-tests/). You won't gain anything from testing simple getters or setters or other trivial implementations (e.g. without any conditional logic). Save the time, that's one more meeting you can attend, hooray!

#### 测试结构

一个好的测试结构（不局限于单元测试）是这样的：

> A good structure for all your tests (this is not limited to unit tests) is this one:

1. 准备测试数据

> 1.Set up the test data

2. 调用被测方法

> 2.Call your method under test

3. 断言返回的是你期待的结果

> 3.Assert that the expected results are returned

这里有个口诀可以帮你记住这种结构：[“Arrange，Act，Assert”](https://xp123.com/articles/3a-arrange-act-assert/)。另一个口诀则是从BDD获取的灵感。就是[“given”，“when”，“then”](https://martinfowler.com/bliki/GivenWhenThen.html)三件套，given说的是准备数据，when指的是调用方法，then则是断言。

> There's a nice mnemonic to remember this structure: ["Arrange, Act, Assert"](https://xp123.com/articles/3a-arrange-act-assert/). Another one that you can use takes inspiration from BDD. It's the ["given", "when", "then"](https://martinfowler.com/bliki/GivenWhenThen.html) triad, where given reflects the setup, when the method call and then the assertion part.

这种模式也可以应用于其他更高层次的测试。在任何情况下，它们都能让你的测试保持一致，易于阅读。除此之外，使用这种结构写出来的测试，往往更简短，更具表达力。

> This pattern can be applied to other, more high-level tests as well. In every case they ensure that your tests remain easy and consistent to read. On top of that tests written with this structure in mind tend to be shorter and more expressive.

#### 实现一个单元测试

知道了测什么、如何组织单元测试后，我们终于可以看一个真正的例子了。

> Now that we know what to test and how to structure our unit tests we can finally see a real example.

让我们来看一个简化版的ExampleController类：

> Let's take a simplified version of the ExampleController class:

```java
@RestController
public class ExampleController {

    private final PersonRepository personRepo;

    @Autowired
    public ExampleController(final PersonRepository personRepo) {
        this.personRepo = personRepo;
    }

    @GetMapping("/hello/{lastName}")
    public String hello(@PathVariable final String lastName) {
        Optional<Person> foundPerson = personRepo.findByLastName(lastName);

        return foundPerson
                .map(person -> String.format("Hello %s %s!",
                        person.getFirstName(),
                        person.getLastName()))
                .orElse(String.format("Who is this '%s' you're talking about?",
                        lastName));
    }
}
```

一个针对`hello(lastname)`方法的单元测试可能是这样的：

> A unit test for the hello(lastname) method could look like this:

```java
public class ExampleControllerTest {

    private ExampleController subject;

    @Mock
    private PersonRepository personRepo;

    @Before
    public void setUp() throws Exception {
        initMocks(this);
        subject = new ExampleController(personRepo);
    }

    @Test
    public void shouldReturnFullNameOfAPerson() throws Exception {
        Person peter = new Person("Peter", "Pan");
        given(personRepo.findByLastName("Pan"))
            .willReturn(Optional.of(peter));

        String greeting = subject.hello("Pan");

        assertThat(greeting, is("Hello Peter Pan!"));
    }

    @Test
    public void shouldTellIfPersonIsUnknown() throws Exception {
        given(personRepo.findByLastName(anyString()))
            .willReturn(Optional.empty());

        String greeting = subject.hello("Pan");

        assertThat(greeting, is("Who is this 'Pan' you're talking about?"));
    }
}
```

我们写单元测试用的是[JUnit](http://junit.org/)，Java实际意义上的标准测试框架。我们使用[Mockito](http://site.mockito.org/)来stub掉真正的`PersonRepository`类。这个stub允许我们在测试里重新定义PersonRepository被调用后产生的响应。stub能让我们的测试更简单，更可预测，更容易组织测试数据。

> We're writing the unit tests using [JUnit](http://junit.org/), the de-facto standard testing framework for Java. We use [Mockito](http://site.mockito.org/) to replace the real PersonRepository class with a stub for our test. This stub allows us to define canned responses the stubbed method should return in this test. Stubbing makes our test more simple, predictable and allows us to easily setup test data.

依照Arrange，Act，Assert的结构，我们写了两个单元测试：一个是正常的场景，另一个是找不到搜索人的场景。首先，正常场景创建了一个新的person对象，然后告诉mock类，当你接受到以“Pan”作为参数的调用时，返回这个person对象。这个测试接着调用了被测试方法。最后它断言返回值是等于期待结果的。

> Following the arrange, act, assert structure, we write two unit tests - a positive case and a case where the searched person cannot be found. The first, positive test case creates a new person object and tells the mocked repository to return this object when it's called with "Pan" as the value for the lastName parameter. The test then goes on to call the method that should be tested. Finally it asserts that the response is equal to the expected response.

第二个测试和第一个类似，但它测试的是被测方法找不到对应人名时的场景。

> The second test works similarly but tests the scenario where the tested method does not find a person for the given parameter.

## 集成测试

所有常见的应用都会和一些外部环境做集成（数据库，文件系统，向其他应用发起网络请求）。为了使测试有更好的隔离、运行更快，我们通常不会在编写单元测试时涉及这些外部依赖。不过，这些交互始终是存在的，它们也需要被测试覆盖到。这正是集成测试的用处所在。它们测试的是应用与所有外部依赖的集成。

> > 「这些常常是写单元测试中需要忽略的部分」这个半句很好。不过后面的「这将带来…的测试」有点翻译腔。我想到两种译法，要么润色下后半句，要么全句拆成更短的短句。我倾向后种。
> >
> > * 这些常常是写单元测试中需要忽略的部分，它可以让单元测试更独立、运行更快。
> > * 为了使测试有更好的隔离、运行更快，我们通常不会在编写单元测试时涉及这些外部依赖。
> >
> >
> >
> > ITs are there to help 的 help 不一定需要译成帮助 -> 伸出援手的意思。

> All non-trivial applications will integrate with some other parts (databases, filesystems, network calls to other applications). When writing unit tests these are usually the parts you leave out in order to come up with better isolation and faster tests. Still, your application will interact with other parts and this needs to be tested. Integration Tests are there to help. They test the integration of your application with all the parts that live outside of your application.

对于自动化测试来说，你不仅需要运行你自己的应用，也需要运行你与之集成的组件。如果你要测试和数据库的集成，那就需要在跑测试的时候运行数据库。如果要测试能否从硬盘里读取文件，你需要先保存一个文件到硬盘上，然后在集成测试中去读取它。

> For your automated tests this means you don't just need to run your own application but also the component you're integrating with. If you're testing the integration with a database you need to run a database when running your tests. For testing that you can read files from a disk you need to save a file to your disk and load it in your integration test.

前面我提到过「单元测试」是一个模糊的术语，对于集成测试而言，更是如此。对于一些人来讲，【待校对：集成测试意味着测试链接到其他系统的整个应用（不隔离外部服务，数据库）】。我理解的集成测试更加狭义：每次只测试一个集成点。测试时应使用测试替身来替代其他的外部服务、数据库等。同时，使用契约测试对测试替身和真实实现进行覆盖。这样出来的集成测试更快，更独立，更易理解和调试。

> I mentioned before that "unit tests" is a vague term, this is even more true for "integration tests". For some people integration testing means to test through the entire stack of your application connected to other applications within your system. I like to treat integration testing more narrowly and test one integration point at a time by replacing separate services and databases with test doubles. Together with contract testing and running contract tests against test doubles as well as the real implementations you can come up with integration tests that are faster, more independent and usually easier to reason about.

狭义的集成测试测的是服务的边界。从概念上来说，这样的测试总是在触发导致应用和外部依赖（文件系统，数据库，其他服务等）集成的行为。比如说，一个数据库集成测试可能会这么写：

> Narrow integration tests live at the boundary of your service. Conceptually they're always about triggering an action that leads to integrating with the outside part (filesystem, database, separate service). A database integration test would look like this:

![图6](https://martinfowler.com/articles/practical-test-pyramid/dbIntegrationTest.png)

*图6：一个集成了你的代码和数据库的集成测试*

1. 启动数据库
2. 连接应用到数据库
3. 调用被测函数，该函数会往数据库写数据
4. 读取数据库，查看期望的数据是不是被写到了数据库里

> 1. start a database
> 2. connect your application to the database
> 3. trigger a function within your code that writes data to the database
> 4. check that the expected data has been written to the database by reading the data from the database

另一个例子，一个通过REST API和外部服务集成的测试可能是会这么写:

> Another example, testing that your service integrates with a separate service via a REST API could look like this:

![图7](https://martinfowler.com/articles/practical-test-pyramid/httpIntegrationTest.png)

*图7：这种集成测试检查了应用是否能正确和外部服务通信*

1. 启动应用
2. 启动一个被测外部服务的实例（或者一个具有相同接口的测试替身）
3. 调用被测函数，该函数会从外部服务的 API 读取数据
4. 检查应用是否能正确解析返回结果

> 1. start your application
> 2. start an instance of the separate service (or a test double with the same interface)
> 3. trigger a function within your code that reads from the separate service's API
> 4. check that your application can parse the response correctly

与单元测试一样，集成测试也可以写得很白盒。一些框架在应用启动后，仍然支持对应用的一些部分进行 mock。 这使得你可以去检查正确的交互是否发生。

> Your integration tests - like unit tests - can be fairly whitebox. Some frameworks allow you to start your application while still being able to mock some other parts of your application so that you can check that the correct interactions have happened.

代码中所有涉及数据序列化和反序列化的地方都要写集成测试。这些场景可能比你想象得更多，比如说：

> Write integration tests for all pieces of code where you either serialize or deserialize data. This happens more often than you might think. Think about:

- 调用自身服务的REST API
- 读写数据库
- 调用外部服务的API
- 读写队列
- 写入文件系统

> - Calls to your services' REST API
> - Reading from and writing to databases
> - Calling other application's APIs
> - Reading from and writing to queues
> - Writing to the filesystem

为这些边界编写集成测试，保证了对外部系统的数据读写操作是正常工作的。

> Writing integration tests around these boundaries ensures that writing data to and reading data from these external collaborators works fine.

编写狭义的集成测试时，你应该尽可能在本地运行外部依赖，如启动一个本地的MySQL数据库、针对本地的ext4文件系统进行测试等。如果是与外部服务集成，可以在本地运行该服务的实例，或构建一个模拟真实服务的假服务，并在本地运行。

> > aim to 表示目标，但不一定时时都能做到。所以译为「尽量」。下段则介绍那些没法在本地启动的外部依赖应该怎么处理。

> When writing narrow integration tests you should aim to run your external dependencies locally: spin up a local MySQL database, test against a local ext4 filesystem. If you're integrating with a separate service either run an instance of that service locally or build and run a fake version that mimics the behaviour of the real service.

如果有些三方服务，你没法在本地运行一个实例，那么可以考虑运行一个专用实例，并在集成测试中指向它。避免在自动化测试里集成真实的生产环境的服务。在生产环境上爆出上千个测试请求是个惹人生气的好办法，因为你会扰乱日志（这是最好的情况），最坏的情况是你会对该服务产生 DoS 攻击。透过网络和一个服务集成是广义集成测试的一大特征，这会让你的测试更慢，通常也更难编写。

> If there's no way to run a third-party service locally you should opt for running a dedicated test instance and point at this test instance when running your integration tests. Avoid integrating with the real production system in your automated tests. Blasting thousands of test requests against a production system is a surefire way to get people angry because you're cluttering their logs (in the best case) or even DoS 'ing their service (in the worst case). Integrating with a service over the network is a typical characteristic of a broad integration test and makes your tests slower and usually harder to write.

在测试金字塔中，集成测试的层级比单元测试更高。集成缓慢的外部依赖（如文件系统或数据库等）通常比隔离了这些依赖的单元测试需要更长时间。他们可能比小型并且独立的单元测试难写，毕竟你需要让外部依赖在你的测试中运行起来。然而，它的优势在于建立了你对应用能正确访问外部依赖的自信，这是单纯的单元测试做不到的。

> With regards to the test pyramid, integration tests are on a higher level than your unit tests. Integrating slow parts like filesystems and databases tends to be much slower than running unit tests with these parts stubbed out. They can also be harder to write than small and isolated unit tests, after all you have to take care of spinning up an external part as part of your tests. Still, they have the advantage of giving you the confidence that your application can correctly work with all the external parts it needs to talk to. Unit tests can't help you with that.

#### 数据库集成

```PersonRepository``` 是代码里唯一的数据库类。它依赖于*Spring Data*，我们并没有实际去实现它。只需要继承```CrudRepository```接口并声明一个方法名。剩下的就是 Spring 魔法了，Spring 会帮我们实现其他所有的东西。

> The ```PersonRepository``` is the only repository class in the codebase. It relies on *Spring Data* and has no actual implementation. It just extends the ```CrudRepository``` interface and provides a single method header. The rest is Spring magic.

```
public interface PersonRepository extends CrudRepository<Person, String> {
    Optional<Person> findByLastName(String lastName);
}
```

对于```CrudRepository```接口，Spring Boot提供了完整的CRUD方法例如```findOne```, ```findAll```, ```save```, ```update```和```delete```。我们自定义的方法（```findByLastName()```）继承了这些基础功能并实现了根据last name获取Persons对象的功能。Spring Data会解析方法的返回类型，并按照命名规范解析方法名，从而决定如何实现方法。

> With the ```CrudRepository``` interface Spring Boot offers a fully functional CRUD repository with ```findOne```, ```findAll```, ```save```, ```update``` and ```delete``` methods. Our custom method definition (```findByLastName()```) extends this basic functionality and gives us a way to fetch Persons by their last name. Spring Data analyses the return type of the method and its method name and checks the method name against a naming convention to figure out what it should do.

虽然Spring Data已经实现了和数据库交互的功能，我还是写了一个数据库集成测试。你可能会反对，认为这是在测试框架，而我们应该避免测试不属于我们开发的代码。然则，我坚信在这里写一个集成测试是至关重要的。首先它测试了我们自定义的findByLastName方法实际的行为如我们所愿。次之，它证明了我们的数据库类正确地使用了Spring的装配特性，它是能正确连接到数据库的。

> Although Spring Data does the heavy lifting of implementing database repositories I still wrote a database integration test. You might argue that this is testing the framework and something that I should avoid as it's not our code that we're testing. Still, I believe having at least one integration test here is crucial. First it tests that our custom findByLastName method actually behaves as expected. Secondly it proves that our repository used Spring's wiring correctly and can connect to the database.

为了让你能更容易在本地把测试运行起来（而不必真的装一个PostgreSQL数据库），我们的测试会连接到一个内存*H2*数据库。

> To make it easier for you to run the tests on your machine (without having to install a PostgreSQL database) our test connects to an in-memory *H2* database.

我已经在```build.gradle```里定义H2作为测试依赖。而测试目录下的```application.properties```没有定义任何```spring.datasource```属性。这会告诉Spring Data使用内存数据库，它会在classpath里找到H2来跑我们的测试。

> I've defined H2 as a test dependency in the ```build.gradle``` file. The ```application.properties``` in the test directory doesn't define any ```spring.datasource``` properties. This tells Spring Data to use an in-memory database. As it finds H2 on the classpath it simply uses H2 when running our tests.

当你用int profile真正启动应用时（例如把```SPRING_PROFILES_ACTIVE=int```设置到环境变量里），它会连接到```application-int.properties```里定义的PostgreSQL数据库。

> When running the real application with the int profile (e.g. by setting ```SPRING_PROFILES_ACTIVE=int``` as environment variable) it connects to a PostgreSQL database as defined in the ```application-int.properties```.

我知道这涉及到了很多Spring的知识。你必须仔细阅读[许多文档](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html#boot-features-embedded-database-support)才能理解这个例子。实现代码只有几行，非常直观，但是如果你不知道Spring的一些知识点是很难加以理解的。

> I know, that's an awful lot of Spring specifics to know and understand. To get there, you'll have to sift through [a lot of documentation](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-sql.html#boot-features-embedded-database-support). The resulting code is easy on the eye but hard to understand if you don't know the fine details of Spring.

除此以外，测试使用内存数据库其实是有风险的。毕竟我们集成测试针对的数据库和我们生产用的数据库不一样。你可以自己选择，是利用Spring的强大能力获得简洁的代码，亦或者是写显式但较为冗长的实现。

> On top of that going with an in-memory database is risky business. After all, our integration tests run against a different type of database than they would in production. Go ahead and decide for yourself if you prefer Spring magic and simple code over an explicit yet more verbose implementation.

解释已经足够多了，这里有一个集成测试的例子。它先保存了一个Person对象到数据库里，然后根据last name去查找它。

> Enough explanation already, here's a simple integration test that saves a Person to the database and finds it by its last name:

```java
@RunWith(SpringRunner.class)
@DataJpaTest
public class PersonRepositoryIntegrationTest {
    @Autowired
    private PersonRepository subject;

    @After
    public void tearDown() throws Exception {
        subject.deleteAll();
    }

    @Test
    public void shouldSaveAndFetchPerson() throws Exception {
        Person peter = new Person("Peter", "Pan");
        subject.save(peter);

        Optional<Person> maybePeter = subject.findByLastName("Pan");

        assertThat(maybePeter, is(Optional.of(peter)));
    }
}
```

你可以看到我们的集成测试像单元测试那样遵循了*arrange*, *act*, *assert*的结构。这可是一个普适概念。

> You can see that our integration test follows the same *arrange*, *act*, *assert* structure as the unit tests. Told you that this was a universal concept!

#### 和外部服务集成

我们的微服务会调用[darksky.net](https://darksky.net/)，一个天气的REST API。当然我们希望保证我们调用时能发送正确的请求，能正确解析应答。

> Our microservice talks to [darksky.net](https://darksky.net/), a weather REST API. Of course we want to ensure that our service sends requests and parses the responses correctly.

我们希望在跑自动化测试时避免真实调用*darksky*的服务。我们计划的配额限制这是一部分原因（译者注：这句怎么翻译？）。真正的原因是*去耦合*。我们的测试应该能独立运行，不管darsky.net的人们在做些啥。即使我们的机器访问不到*darksky*服务器，亦或是*darksky*服务器因为维护宕机了。

> We want to avoid hitting the real *darksky* servers when running automated tests. Quota limits of our free plan are only part of the reason. The real reason is *decoupling*. Our tests should run independently of whatever the lovely people at darksky.net are doing. Even when your machine can't access the *darksky* servers or the darksky servers are down for maintenance.

我们可以用我们自己仿制的*darksky*服务器来代替真正的服务器来运行我们的集成测试。这听起来好像很麻烦。幸亏有像[Wiremock](http://wiremock.org/)这样的工具，事情变得很简单。看这里：

> We can avoid hitting the real *darksky* servers by running our own, fake *darksky* server while running our integration tests. This might sound like a huge task. Thanks to tools like [Wiremock](http://wiremock.org/) it's easy peasy. Watch this:

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class WeatherClientIntegrationTest {

    @Autowired
    private WeatherClient subject;

    @Rule
    public WireMockRule wireMockRule = new WireMockRule(8089);

    @Test
    public void shouldCallWeatherService() throws Exception {
        wireMockRule.stubFor(get(urlPathEqualTo("/some-test-api-key/53.5511,9.9937"))
                .willReturn(aResponse()
                        .withBody(FileLoader.read("classpath:weatherApiResponse.json"))
                        .withHeader(CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                        .withStatus(200)));

        Optional<WeatherResponse> weatherResponse = subject.fetchWeather();

        Optional<WeatherResponse> expectedResponse = Optional.of(new WeatherResponse("Rain"));
        assertThat(weatherResponse, is(expectedResponse));
    }
}
```

为了使用Wiremock，我们在固定的端口(8089)实例化了一个```WireMockRule```。使用领域特定语言我们能启动一个Wiremock服务器，定义一个它需要监听的终端，设置一些对特定请求的应答。

> To use Wiremock we instantiate a ```WireMockRule``` on a fixed port (8089). Using the DSL we can set up the Wiremock server, define the endpoints it should listen on and set canned responses it should respond with.

接着我们调用我们希望测试的方法，一个调用第三方服务的方法，然后检查结果是否被正确解析。

> Next we call the method we want to test, the one that calls the third-party service and check if the result is parsed correctly.

理解测试怎样调用Wiremock服务器而不是真正的*darksky*很重要。秘密就在于我们的```src/test/resources```下的```application.properties```。这是Spring在运行测试时会加载的属性文件。出于测试目的，在这个文件我们覆写了一些配置，就像API keys和URLs。例如调用一个假的Wiremock服务器而不是真实服务器：

> It's important to understand how the test knows that it should call the fake Wiremock server instead of the real *darksky* API. The secret is in our ```application.properties``` file contained in ```src/test/resources```. This is the properties file Spring loads when running tests. In this file we override configuration like API keys and URLs with values that are suitable for our testing purposes, e.g. calling the fake Wiremock server instead of the real one:

```weather.url = http://localhost:8089```

值得注意的一点是，这里声明的端口必须和我们在测试里实例化```WireMockRule```时的端口保持一致。我们的测试之所以能这样运行，是因为用假的API URL代替真实的天气服务，并且这个URL就是注入到```WeatherClient```类构造函数的那个。

> Note that the port defined here has to be the same we define when instantiating the ```WireMockRule``` in our test. Replacing the real weather API's URL with a fake one in our tests is made possible by injecting the URL in our ```WeatherClient``` class' constructor:

```java
@Autowired
public WeatherClient(final RestTemplate restTemplate,
                     @Value("${weather.url}") final String weatherServiceUrl,
                     @Value("${weather.api_key}") final String weatherServiceApiKey) {
    this.restTemplate = restTemplate;
    this.weatherServiceUrl = weatherServiceUrl;
    this.weatherServiceApiKey = weatherServiceApiKey;
}
```

这样我们告诉```WeatherClient```要把我们定义在application properties的```weather.url```的值赋给```weatherUrl```。

> This way we tell our ```WeatherClient``` to read the ```weatherUrl``` parameter's value from the ```weather.url``` property we define in our application properties.

借助类似Wiremock这样的工具，针对外部服务撰写*狭义集成测试*变得很简单。不幸的是这种方式有个缺点：我们怎么保证我们启动的假服务行为和真的服务是一样的？就目前的实现来说，外部服务可能改变它的API，但我们的测试依然能跑过。我们仅仅测试了```WeatherClient```可以解析假服务器返回的应答信息。这仅仅是一个开始，并且它是易碎品。使用*端到端测试*，针对真实服务的实例运行测试，而不使用假的服务，当然能解决这个问题。但是这会让我们对测试服务的可用性产生依赖。幸运的是，这里还有一个更好的办法可以让你走出窘境。针对真实和假的服务运行契约测试，保证我们集成测试里的假服务是个可信赖的测试替身。接下来让我们看看契约测试又是什么。

> Writing *narrow integration tests* for a separate service is quite easy with tools like Wiremock. Unfortunately there's a downside to this approach: How can we ensure that the fake server we set up behaves like the real server? With the current implementation, the separate service could change its API and our tests would still pass. Right now we're merely testing that our ```WeatherClient``` can parse the responses that the fake server sends. That's a start but it's very brittle. Using *end-to-end tests* and running the tests against a test instance of the real service instead of using a fake service would solve this problem but would make us reliant on the availability of the test service. Fortunately, there's a better solution to this dilemma: Running contract tests against the fake and the real server ensures that the fake we use in our integration tests is a faithful test double. Let's see how this works next.

## 契约测试

越来越多现代软件组织发现了把巨大的开发量通过拆分服务分散到不同团队中的方法。独立的团队建立独立，松耦合的服务，团队间开发不互相影响。最终这些服务都集成到一个大而全的系统中。最近微服务的讨论正在关注的是这一点。

> More modern software development organisations have found ways of scaling their development efforts by spreading the development of a system across different teams. Individual teams build individual, loosely coupled services without stepping on each others toes and integrate these services into a big, cohesive system. The more recent buzz around microservices focuses on exactly that.

拆分系统到许多服务中常常意味着这些服务需要互相之间通过确定的(最好是定义明确的，但有时候也会疯狂变更)接口通信。

> Splitting your system into many small services often means that these services need to communicate with each other via certain (hopefully well-defined, sometimes accidentally grown) interfaces.

不同应用间的接口可谓是形形色色，技术多样的。这里举个例子

> Interfaces between different applications can come in different shapes and technologies. Common ones are

- 通过HTTPS使用JSON交互的REST接口
- 基于类似[gRPC](https://grpc.io/)的RPC(Remote Procedure Call)
- 使用队列构建的事件驱动架构

> - REST and JSON via HTTPS
> - RPC using something like [gRPC](https://grpc.io/)
> - building an event-driven architecture using queues

对于一个接口而言，都会涉及到这两部分：提供方和消费方。**提供方**为消费者们提供数据。**消费方**处理从提供方处获取的数据。在REST世界里，提供方为所有需要的API路径构建REST API。消费方调用这些API来获取数据或者触发别的服务上的改动行为。在一个异步，事件驱动的世界，提供方(通常被称为发布者)发布数据到一个队列中；消费者(通常被称为订阅者)订阅这些队列然后读取并处理相关数据。

> For each interface there are two parties involved: the provider and the consumer. The **provider** serves data to consumers. The **consumer** processes data obtained from a provider. In a REST world a provider builds a REST API with all required endpoints; a consumer makes calls to this REST API to fetch data or trigger changes in the other service. In an asynchronous, event-driven world, a provider (often rather called **publisher**) publishes data to a queue; a consumer (often called **subscriber**) subscribes to these queues and reads and processes data.

![图8](https://martinfowler.com/articles/practical-test-pyramid/contract_tests.png)

*图8：每一个接口都有提供方(或者发布者)和消费者(或者订阅者)团体。明确的接口规范可以视为契约。*

*Figure 8: Each interface has a providing (or publishing) and a consuming (or subscribing) party. The specification of an interface can be considered a contract.*

当你经常流连于由不同团队消费服务或提供服务的场景时，你会发现你必须清晰了解知道这些服务间的接口(所谓的**契约**)。传统公司有这样的办法解决契约这个问题：

> As you often spread the consuming and providing services across different teams you find yourself in the situation where you have to clearly specify the interface between these services (the so called **contract**). Traditionally companies have approached this problem in the following way:

- 写一个很长并且很详细的接口(契约)文档
- 根据定义好的契约实现提供方服务
- 把接口文档扔给消费团队
- 等待，直到团队把消费部分实现
- 运行大规模的手动系统间测试来保证软件正常工作
- 希望双方团队都永远维持接口定义，不要把事情搞砸

> - Write a long and detailed interface specification (the contract)
> - Implement the providing service according to the defined contract
> - Throw the interface specification over the fence to the consuming team
> - Wait until they implement their part of consuming the interface
> - Run some large-scale manual system test to see if everything works
> - Hope that both teams stick to the interface definition forever and don't screw up

越来越多现代软件开发团队已经把第五步和第六步用更加自动化的方式来替代：自动化[契约测试](https://martinfowler.com/bliki/ContractTest.html)保证了消费方和提供方实现的时候依然遵循契约。这种测试提供了一个良好的回归测试组合，保证在契约出现偏差时能及早发现。

> More modern software development teams have replaced steps 5. and 6. with something more automated: Automated [contract tests](https://martinfowler.com/bliki/ContractTest.html) make sure that the implementations on the consumer and provider side still stick to the defined contract. They serve as a good regression test suite and make sure that deviations from the contract will be noticed early.

在现代敏捷组织，你应该选择效率高少浪费的路子。在同样的组织下构建应用。比起扔一个详尽的文档过去，和维护外部服务的开发者们直接交流真的不应该如此的艰难。毕竟他们是你的同事而不是第三方供应商，后者也许只能通过客户支持或者合法全面的合同来交流。

> In a more agile organisation you should take the more efficient and less wasteful route. You build your applications within the same organisation. It really shouldn't be too hard to talk to the developers of the other services directly instead of throwing overly detailed documentation over the fence. After all they're your co-workers and not a third-party vendor that you could only talk to via customer support or legally bulletproof contracts.

**消费方驱动的契约测试**(Consumer-Driven Contract tests，CDC测试)是让[消费者驱动契约实现](https://martinfowler.com/articles/consumerDrivenContracts.html)。使用CDC，接口消费者会写测试检查接口返回的所有数据是不是他们想要的。消费方团队会发布这些测试从而让提供方可以获取到这些测试并执行。提供方团队现在可以一边运行CDC测试一边开发他们的API了。一旦所有测试通过，他们就知道已经实现了所有消费方想要的东西。

> **Consumer-Driven Contract tests** (CDC tests) let the [consumers drive the implementation of a contract](https://martinfowler.com/articles/consumerDrivenContracts.html). Using CDC, consumers of an interface write tests that check the interface for all data they need from that interface. The consuming team then publishes these tests so that the publishing team can fetch and execute these tests easily. The providing team can now develop their API by running the CDC tests. Once all tests pass they know they have implemented everything the consuming team needs.

![图9](https://martinfowler.com/articles/practical-test-pyramid/cdc_tests.png)

*图9：契约测试保证了提供方和所有的消费方基于同一个接口依照了定义好的接口契约。用CDC测试，消费者就可以通过自动化测试发布他们的需求，提供方则可以持续不断获取这些测试并执行*
*Figure 9: Contract tests ensure that the provider and all consumers of an interface stick to the defined interface contract. With CDC tests consumers of an interface publish their requirements in the form of automated tests; the providers fetch and execute these tests continuously*

这种方式允许提供方团队只实现必要的东西(让设计保持简约，[YAGNI](https://martinfowler.com/bliki/Yagni.html)等)。提供方团队需要持续不断地获取并运行这些CDC测试(从他们的构建Pipeline里)，从而能立即发现任何打破契约的代码变更。如果有代码变更破坏了接口，CDC测试应该会执行失败，这样可以防止破坏性改动上线。当这些测试保持通过，团队就可以做任何他们想做的改动而不需要担心其他团队。CDC这种方式将会让你看到类似这样的过程：

> This approach allows the providing team to implement only what's really necessary (keeping things simple, YAGNI and all that). The team providing the interface should fetch and run these CDC tests continuously (in their build pipeline) to spot any breaking changes immediately. If they break the interface their CDC tests will fail, preventing breaking changes to go live. As long as the tests stay green the team can make any changes they like without having to worry about other teams. The Consumer-Driven Contract approach would leave you with a process looking like this:

- 消费方团队根据他们的期待结果撰写自动化测试
- 发布自动化测试给提供方团队
- 提供方持续不断运行这些测试并保持他们都能通过
- 双方在CDC测试被打破时需要保持良好沟通

> - The consuming team writes automated tests with all consumer expectations
> - They publish the tests for the providing team
> - The providing team runs the CDC tests continuously and keeps them green
> - Both teams talk to each other once the CDC tests break

如果你的组织践行了微服务，那么拥有CDC测试将是建立自治团队的一大步。CDC测试是一种促进团队交流的自动化途径。他们保证团队之间的接口在任何时候都是工作的。暂时失败的CDC测试是一个良好的只是去，它告诉你需要考虑受影响的团队了。和这些团队聊聊即将到来的API改动，并谈谈你希望下一步如何发展。

> If your organisation adopts a microservices approach, having CDC tests is a big step towards establishing autonomous teams. CDC tests are an automated way to foster team communication. They ensure that interfaces between teams are working at any time. Failing CDC tests are a good indicator that you should walk over to the affected team, have a chat about any upcoming API changes and figure out how you want to move forward.

一个稚嫩的CDC测试实现非常简单，比如说你可以对一个API发请求并断言响应包含了你需要的所有东西。然后你把这些测试打包成可执行文件(.gem, .jar, .sh)并上传到一个其他团队可以获取它的地方(例如一些像[Artifactory](https://www.jfrog.com/artifactory/)那样的仓库)。

> A naive implementation of CDC tests can be as simple as firing requests against an API and assert that the responses contain everything you need. You then package these tests as an executable (.gem, .jar, .sh) and upload it somewhere the other team can fetch it (e.g. an artifact repository like [Artifactory](https://www.jfrog.com/artifactory/)).

在过去几年里，CDC正变得越来越受欢迎，也产生了一些让撰写，上传CDC更简单的工具。

> Over the last couple of years the CDC approach has become more and more popular and several tools been build to make writing and exchanging them easier.

[Pact](https://github.com/realestate-com-au/pact)应该是这些日子里最显眼的工具。它有全面的方式来撰写提供方或者消费方的测试，它给你提供开箱即用的仿造其他服务的方式，它也能让你方便的和其他团队交换CDC测试。Pact已经被移植到多平台上，可以和JVM语言一起使用，例如Ruby，.NET，JavaScript等。

> [Pact](https://github.com/realestate-com-au/pact) is probably the most prominent one these days. It has a sophisticated approach of writing tests for the consumer and the provider side, gives you stubs for separate services out of the box and allows you to exchange CDC tests with other teams. Pact has been ported to a lot of platforms and can be used with JVM languages, Ruby, .NET, JavaScript and many more.

如果你想开始撰写CDC测试，但是不知道怎么开始，Pact是一个明智的选择。[文档](https://docs.pact.io/)一开始可能会让你应接不暇。保持耐心克服一下。它帮助你深刻理解CDC，也会让你更容易在团队合作时推行CDC。

> If you want to get started with CDCs and don't know how, Pact can be a sane choice. The [documentation](https://docs.pact.io/) can be overwhelming at first. Be patient and work through it. It helps to get a firm understanding for CDCs which in turn makes it easier for you to advocate for the use of CDCs when working with other teams.

消费方驱动契约测试真的可以说是建立自治团队的基石，它让这些团队更快前行，充满自信。帮帮你自己，l好好了解一下CDC这个概念，然后尝试一下。稳固的CDC测试组合在快速前进时显得非常宝贵，它让你不会打破其他团队的功能，也不会让其他团队失望。

> Consumer-Driven Contract tests can be a real game changer to establish autonomous teams that can move fast and with confidence. Do yourself a favor, read up on that concept and give it a try. A solid suite of CDC tests is invaluable for being able to move fast without breaking other services and cause a lot of frustration with other teams.

#### 消费方测试（我方团队）

我们例子程序里的微服务消费了天气API。所以我们有责任写**消费方测试**来定义我们期望从API契约中获得的结果。

> Our microservice consumes the weather API. So it's our responsibility to write a **consumer test** that defines our expectations for the contract (the API) between our microservice and the weather service.

首先我们先在```build.gradle```里引入一个库来写基于协议的消费方测试：

> First we include a library for writing pact consumer tests in our ```build.gradle```:

```testCompile('au.com.dius:pact-jvm-consumer-junit_2.11:3.5.5')```

得益于这个库，我们可以用协议的仿造服务来实现一个消费方测试：

> Thanks to this library we can implement a consumer test and use pact's mock services:

```java
@RunWith(SpringRunner.class)
@SpringBootTest
public class WeatherClientConsumerTest {

    @Autowired
    private WeatherClient weatherClient;

    @Rule
    public PactProviderRuleMk2 weatherProvider =
            new PactProviderRuleMk2("weather_provider", "localhost", 8089, this);

    @Pact(consumer="test_consumer")
    public RequestResponsePact createPact(PactDslWithProvider builder) throws IOException {
        return builder
                .given("weather forecast data")
                .uponReceiving("a request for a weather request for Hamburg")
                    .path("/some-test-api-key/53.5511,9.9937")
                    .method("GET")
                .willRespondWith()
                    .status(200)
                    .body(FileLoader.read("classpath:weatherApiResponse.json"),
                            ContentType.APPLICATION_JSON)
                .toPact();
    }

    @Test
    @PactVerification("weather_provider")
    public void shouldFetchWeatherInformation() throws Exception {
        Optional<WeatherResponse> weatherResponse = weatherClient.fetchWeather();
        assertThat(weatherResponse.isPresent(), is(true));
        assertThat(weatherResponse.get().getSummary(), is("Rain"));
    }
}
```

如果你观察得仔细，你会发现```WeatherClientConsumerTest```真的和```WeatherClientIntegrationTest```很相似。这次我们用协议来取代Wiremock模仿服务的功能。事实上消费方测试就是集成测试，我们用仿造的方式隔离了第三方服务，定义了我们期待的响应，检查我们客户端可以正确处理响应。某种意义上来说```WeatherClientConsumerTest```是一个狭隘集成测试。基于Wiremock的好处是，它每次运行都会创建一个*协议文件*(你可以在这里找到```target/pacts/&pact-name>.json```)。这个协议文件用特殊的JSON格式描述了这个契约的期待的结果。这也能用于验证我们仿造的服务行为就跟真实服务是一样的。我们可以把这个协议文件交给提供API的团队，他们可以根据这个文件的期待结果来撰写提供方测试。这样的话他们就能测试他们的API是不是满足了所有期待结果。

> If you look closely, you'll see that the ```WeatherClientConsumerTest``` is very similar to the ```WeatherClientIntegrationTest```. Instead of using Wiremock for the server stub we use Pact this time. In fact the consumer test works exactly as the integration test, we replace the real third-party server with a stub, define the expected response and check that our client can parse the response correctly. In this sense the ```WeatherClientConsumerTest``` is a narrow integration test itself. The advantage over the wiremock-based test is that this test generates a *pact file* (found in ```target/pacts/&pact-name>.json```) each time it runs. This pact file describes our expectations for the contract in a special JSON format. This pact file can then be used to verify that our stub server behaves like the real server. We can take the pact file and hand it to the team providing the interface. They take this pact file and write a provider test using the expectations defined in there. This way they test if their API fulfils all our expectations.

消费方通过他们期待结果来驱动接口实现，这就是CDC里消费方驱动所想要表达的意思。提供方必须保证他们满足所有期待结果，没有过度设计，保持简洁。

> You see that this is where the consumer-driven part of CDC comes from. The consumer drives the implementation of the interface by describing their expectations. The provider has to make sure that they fulfil all expectations and they're done. No gold-plating, no YAGNI and stuff.

把Pact文件交给提供方团队可以有几种方式，一种简单方式就是把它们加入到版本控制系统里，告诉提供方去拉取最新的文件即可。更先进一点的方式则是用一个文件仓库，类似Amazon S3这样的或者pact broker。起步迅速，容易拓展。

> Getting the pact file to the providing team can happen in multiple ways. A simple one is to check them into version control and tell the provider team to always fetch the latest version of the pact file. A more advances one is to use an artifact repository, a service like Amazon's S3 or the pact broker. Start simple and grow as you need.

在真实的软件中你并不需要为一个客户端类既写集成测试又写消费方测试。示例代码库包含了这两种测试只是想告诉你这两种测试的写法。如果你想用协议来写CDC测试，我推荐你只写消费方测试。写这两种测试的成本是一样的。用协议的方式就有协议文件这个好处，这样把协议文件递交给其他团队，他们就能很容易实现他们的提供方测试。当然这取决于你能说服其他团队也使用协议。如果很不幸，那么用Wiremock来实现集成测试可以作为替代方案。

> In your real-world application you don't need both, an integration test and a consumer test for a client class. The sample codebase contains both to show you how to use either one. If you want to write CDC tests using pact I recommend sticking to the latter. The effort of writing the tests is the same. Using pact has the benefit that you automatically get a pact file with the expectations to the contract that other teams can use to easily implement their provider tests. Of course this only makes sense if you can convince the other team to use pact as well. If this doesn't work, using the integration test and Wiremock combination is a decent plan b.

#### 提供方测试（其他团队）

提供方测试必须由提供天气API的团队来实现。我们正在消费一个darksky.net提供的公共API。按道理darksky团队会实现提供方测试，以保证不打破他们应用和我们服务之间的契约。

> The provider test has to be implemented by the people providing the weather API. We're consuming a public API provided by darksky.net. In theory the darksky team would implement the provider test on their end to check that they're not breaking the contract between their application and our service.

很明显他们不会关注我们这个简单的示例代码库，也不会为我们实现CDC测试。这是公共API和组织内微服务的一大不同点。公共API不可能考虑到每一个消费方，否则他们将无法前行。在我们自己组织内，你可以你也应该考虑每个消费方。你的应用最多只会服务少量，最多几十个消费方。你可以很好的为这些接口写提供方测试以保证系统稳定。

> Obviously they don't care about our meager sample application and won't implement a CDC test for us. That's the big difference between a public-facing API and an organisation adopting microservices. Public-facing APIs can't consider every single consumer out there or they'd become unable to move forward. Within your own organisation, you can — and should. Your app will most likely serve a handful, maybe a couple dozen of consumers max. You'll be fine writing provider tests for these interfaces in order to keep a stable system.

提供方团队拿到协议文件后，需要实现提供方测试来读取协议文件，仿造掉一些测试数据，用他们提供的服务运行检查是否为协议文件中期待的结果。

> The providing team gets the pact file and runs it against their providing service. To do so they implement a provider test that reads the pact file, stubs out some test data and runs the expectations defined in the pact file against their service.

喜欢协议的人写了几个库来实现提供方测试，他们主要的[GitHub仓库](https://github.com/DiUS/pact-jvm)告诉你用什么库来实现提供方或者消费方测试，你只需要去选择契合你现在技术栈的即可。

> The pact folks have written several libraries for implementing provider tests. Their main [GitHub repo](https://github.com/DiUS/pact-jvm) gives you a nice overview which consumer and which provider libraries are available. Pick the one that best matches your tech stack.

为了简单起见，我们假设darksky的API也是用Spring Boot来实现的。这样的话他们就可以用[Spring pact provider](https://github.com/DiUS/pact-jvm/tree/master/pact-jvm-provider-spring)来写，这个库和Spring的MockMVC机制结合得很好。我们假想darksky.net团队写了提供方测试，那么它大概长这样：

> For simplicity let's assume that the darksky API is implemented in Spring Boot as well. In this case they could use the [Spring pact provider](https://github.com/DiUS/pact-jvm/tree/master/pact-jvm-provider-spring) which hooks nicely into Spring's MockMVC mechanisms. A hypothetical provider test that the darksky.net team would implement could look like this:

```java
@RunWith(RestPactRunner.class)
@Provider("weather_provider") // same as the "provider_name" in our clientConsumerTest
@PactFolder("target/pacts") // tells pact where to load the pact files from
public class WeatherProviderTest {
    @InjectMocks
    private ForecastController forecastController = new ForecastController();

    @Mock
    private ForecastService forecastService;

    @TestTarget
    public final MockMvcTarget target = new MockMvcTarget();

    @Before
    public void before() {
        initMocks(this);
        target.setControllers(forecastController);
    }

    @State("weather forecast data") // same as the "given()" in our clientConsumerTest
    public void weatherForecastData() {
        when(forecastService.fetchForecastFor(any(String.class), any(String.class)))
                .thenReturn(weatherForecast("Rain"));
    }
}
```

你可以看到提供方测试必须加载一个协议文件(例如用```@PactFolder```注解来自动装配之前下载好的协议文件)然后才能定义基于预设State提供出去的数据(例如使用Mockito来仿造)。没有额外的东西需要实现，他们全都应该从协议文件派生出来。对于消费方测试里的*提供方名称*和State声明，提供方测试应该一一匹配。

> You see that all the provider test has to do is to load a pact file (e.g. by using the ```@PactFolder``` annotation to load previously downloaded pact files) and then define how test data for pre-defined states should be provided (e.g. using Mockito mocks). There's no custom test to be implemented. These are all derived from the pact file. It's important that the provider test has matching counterparts to the *provider name* and state declared in the consumer test.

#### 提供方测试（我方团队）

我们已经看了如何测试我们服务和天气提供方之间的契约。用这个接口的话，我们的服务扮演的是消费方，天气服务扮演了提供方。考虑得更远一些，我们可以看到我们的服务也会对一些别的系统扮演提供方的角色：我们为数个路径提供REST API，时刻准备着被其他系统消费。

> We've seen how to test the contract between our service and the weather provider. With this interface our service acts as consumer, the weather service acts as provider. Thinking a little further we'll see that our service also acts as a provider for others: We provide a REST API that offers a couple of endpoints ready to be consumed by others.

我们刚认识到了契约测试风靡一时，当然我们也会想给我们的契约写一写契约测试。幸运的是我们使用了消费方驱动契约，所以所有的消费方都会给我们发协议，这样就能用来给我们的REST API实现提供方测试。

> As we've just learned that contract tests are all the rage, we of course write a contract test for this contract as well. Luckily we're using consumer-driven contracts so there's all the consuming teams sending us their Pacts that we can use to implement our provider tests for our REST API.

先把pact-jvm-provider库装上：

> Let's first add the Pact provider library for Spring to our project:

```testCompile('au.com.dius:pact-jvm-provider-spring_2.12:3.5.5')```

同样我们用之前说过的范式来实现提供方测试。为了简单起见我们直接从[simple consumer](https://github.com/hamvocke/spring-testing-consumer)获得协议文件，并放到我们的仓库中，这会让我们操作起来简单一些。在真实的场景你当然要用更复杂一些的机制来分发接受协议文件。

> Implementing the provider test follows the same pattern as described before. For the sake of simplicity I simply checked the pact file from our [simple consumer](https://github.com/hamvocke/spring-testing-consumer) into our service's repository. This makes it easier for our purpose, in a real-life scenario you're probably going to use a more sophisticated mechanism to distribute your pact files.

```java
@RunWith(RestPactRunner.class)
@Provider("person_provider")// same as in the "provider_name" part in our pact file
@PactFolder("target/pacts") // tells pact where to load the pact files from
public class ExampleProviderTest {

    @Mock
    private PersonRepository personRepository;

    @Mock
    private WeatherClient weatherClient;

    private ExampleController exampleController;

    @TestTarget
    public final MockMvcTarget target = new MockMvcTarget();

    @Before
    public void before() {
        initMocks(this);
        exampleController = new ExampleController(personRepository, weatherClient);
        target.setControllers(exampleController);
    }

    @State("person data") // same as the "given()" part in our consumer test
    public void personData() {
        Person peterPan = new Person("Peter", "Pan");
        when(personRepository.findByLastName("Pan")).thenReturn(Optional.of
                (peterPan));
    }
}
```

```ExampleProviderTest```需要根据协议文件里的内容提供State。当我们运行提供方测试时，Pact会根据协议文件发送HTTP请求来命中我们的服务，然后从我们建立的State来响应。

> The shown ```ExampleProviderTest``` needs to provide state according to the pact file we're given, that's it. Once we run the provider test, Pact will pick up the pact file and fire HTTP request against our service that then responds according to the state we've set up.

## UI测试

大部分的应用都会有些用户界面。一个典型的例子就是网页应用中的网页页面。人们经常会忘记REST API界面或者命令行界面，它们其实跟多姿多彩的网页页面一样多。

> Most applications have some sort of user interface. Typically we're talking about a web interface in the context of web applications. People often forget that a REST API or a command line interface is as much of a user interface as a fancy web user interface.

*UI测试*测试的是应用中用户界面是否正常。用户的输入需要触发正确的动作，数据需要能展示给用户看，UI状态需要如期望般改变。

> *UI tests* test that the user interface of your application works correctly. User input should trigger the right actions, data should be presented to the user, the UI state should change as expected.

![图10](https://martinfowler.com/articles/practical-test-pyramid/ui_tests.png)

UI测试和端到端测试有时候(就像Mike Cohn的例子那样)说的是一个东西。对我而言我很容易混淆这俩个有交集的概念。

> UI Tests and end-to-end tests are sometimes (as in Mike Cohn's case) said to be the same thing. For me this conflates two things that are rather orthogonal concepts.

诚然，测试应用端到端通常意味着驱动测试经过用户界面。但是反过来讲，并不是这样。

> Yes, testing your application end-to-end often means driving your tests through the user interface. The inverse, however, is not true.

测试用户界面不必非得在端到端的方式下完成。根据技术栈不同，把后端用仿造隔离开的话，写UI测试可以如同对前端js代码写单元测试那般简单。

> Testing your user interface doesn't have to be done in an end-to-end fashion. Depending on the technology you use, testing your user interface can be as simple as writing some unit tests for your frontend javascript code with your backend stubbed out.

传统的网页应用UI测试，可以用一些类似[Selenium](http://docs.seleniumhq.org/)的工具。如果你在想为REST API做UI测试，你应该具备所有条件来为API写合适的集成测试。

> With traditional web applications testing the user interface can be achieved with tools like [Selenium](http://docs.seleniumhq.org/). If you consider a REST API to be your user interface you should have everything you need by writing proper integration tests around your API.

对于网页界面而言，估计你会围绕这几个部分进行：行为，布局，可用性或者也有少数人认为需要去测试的设计一致性。

> With web interfaces there's multiple aspects that you probably want to test around your UI: behaviour, layout, usability or adherence to your corporate design are only a few.

很好，测试界面行为很简单。点击一下，输入数据，希望看到界面如实变更。现代单页应用框架([react](https://facebook.github.io/react/), [vue.js](https://vuejs.org/), [Angular](https://angular.io/)或者类似的东西)通常都会提供一些工具或者组件来让你能从低层级(单元测试)就能测试交互。即便你用普通的js来实现前端，你可以用常规的测试工具例如[Jasmine](https://jasmine.github.io/)或者[Mocha](http://mochajs.org/)。对于更传统一些的服务端渲染应用，基于Selenium的测试将是你最佳的选择。

> Fortunately, testing the behaviour of your user interface is pretty simple. You click here, enter data there and want the state of the user interface to change accordingly. Modern single page application frameworks ([react](https://facebook.github.io/react/), [vue.js](https://vuejs.org/), [Angular](https://angular.io/) and the like) often come with their own tools and helpers that allow you to thoroughly test these interactions in a pretty low-level (unit test) fashion. Even if you roll your own frontend implementation using vanilla javascript you can use your regular testing tools like [Jasmine](https://jasmine.github.io/) or [Mocha](http://mochajs.org/). With a more traditional, server-side rendered application, Selenium-based tests will be your best choice.

测试应用的布局是否完整有些困难。取决于应用和用户的需要，也许你只想保证代码变更不会意外打破页面布局。

> Testing that your web application's layout remains intact is a little harder. Depending on your application and your users' needs you may want to make sure that code changes don't break the website's layout by accident.

问题就在于计算机并不擅长用模糊的方式来评判一些东西看起来是不是好的。(也许一些智能机器学习算法可以改善这一现状)

> The problem is that computers are notoriously bad at checking if something "looks good" (maybe some clever machine learning algorithm can change that in the future).

但是呢，还是有些工具可以在构建Pipeline里自动化地检查网页应用的设计。大部分工具都是基于不同的浏览器，基于不一样的格式利用Selenium来打开网页应用，进行截图并且跟以前的截图做对比。如果新旧截图差异超过了预设阈值，工具就会告诉你。

> There are some tools to try if you want to automatically check your web application's design in your build pipeline. Most of these tools utilise Selenium to open your web application in different browsers and formats, take screenshots and compare these to previously taken screenshots. If the old and new screenshots differ in an unexpected way, the tool will let you know.

[Galen](http://galenframework.com/)是这些工具中的一种。但是呢，你过你有特殊的需求，那么自己定制化一下解决方案也不是很难。一些我工作过的团队建立了[lineup](https://github.com/otto-de/lineup)和基于Java的[jlineup](https://github.com/otto-de/jlineup)，用以实现类似的东西。但是这两种工具都像我前面所说那样用了Selenium。

> [Galen](http://galenframework.com/) is one of these tools. But even rolling your own solution isn't too hard if you have special requirements. Some teams I've worked with built [lineup](https://github.com/otto-de/lineup) and its Java-based cousin [jlineup](https://github.com/otto-de/jlineup) to achieve something similar. Both tools take the same Selenium-based approach I described before.

当你想测试可用性和模糊的“看起来不错”时，其实你已经离开了自动化测试领域。这是[探索性测试](https://en.wikipedia.org/wiki/Exploratory_testing)，可用性测试(这甚至可以像[走廊测试](https://en.wikipedia.org/wiki/Usability_testing#Hallway_testing)那般简单)的领域。你需要给你的用户展示产品，看看他们是否喜欢使用它，是不是在使用每一块功能时不会变得失望或者愤怒。

> Once you want to test for usability and a "looks good" factor you leave the realms of automated testing. This is the area where you should rely on [exploratory testing](https://en.wikipedia.org/wiki/Exploratory_testing), usability testing (this can even be as simple as [hallway testing](https://en.wikipedia.org/wiki/Usability_testing#Hallway_testing)) and showcases with your users to see if they like using your product and can use all features without getting frustrated or annoyed.

## 端到端测试

从用户界面测试部署好的应用，是测试应用最端到端的方式了。像前面所说，web driver驱动的UI测试就是一个端到端测试的例子。

> Testing your deployed application via its user interface is the most end-to-end way you could test your application. The previously described, webdriver driven UI tests are a good example of end-to-end tests.

![图11](https://martinfowler.com/articles/practical-test-pyramid/e2etests.png)

*图11：端到端测试完整的测试了全部的集成系统*

*Figure 11: End-to-end tests test your entire, completely integrated system*

端到端测试(也被称为[广域栈测试](https://martinfowler.com/bliki/BroadStackTest.html))会赋予你最强信心，让你断定软件有没有正常工作。[Selenium](http://docs.seleniumhq.org/)和[WebDriver Protocol](https://www.w3.org/TR/webdriver/)允许你针对部署好的服务进行自动化测试，它能调用无头(headless)浏览器来对用户界面执行点击，输入，检查状态的操作。当然你也可以直接使用Selenium，也可以用类似[Nightwatch](http://nightwatchjs.org/)这种建立于Selenium基础上的工具。

> End-to-end tests (also called [Broad Stack Tests](https://martinfowler.com/bliki/BroadStackTest.html)) give you the biggest confidence when you need to decide if your software is working or not. [Selenium](http://docs.seleniumhq.org/) and the [WebDriver Protocol](https://www.w3.org/TR/webdriver/) allow you to automate your tests by automatically driving a (headless) browser against your deployed services, performing clicks, entering data and checking the state of your user interface. You can use Selenium directly or use tools that are build on top of it, [Nightwatch](http://nightwatchjs.org/) being one of them.

端到端测试也会有一些问题。众所周知它们常常会因为一些不按套路，意料之外的问题导致测试失败。误报错误十分常见。用户界面越是复杂，这种测试就越是脆弱。浏览器差异，时间问题，动画和预料不到的弹框仅仅是让我花大量时间调试的一些原因，这实在令人沮丧。

> End-to-End tests come with their own kind of problems. They are notoriously flaky and often fail for unexpected and unforeseeable reasons. Quite often their failure is a false positive. The more sophisticated your user interface, the more flaky the tests tend to become. Browser quirks, timing issues, animations and unexpected popup dialogs are only some of the reasons that got me spending more of my time with debugging than I'd like to admit.

在微服务的世界中，谁来负责写这些测试也还是一个大问题。因为端到端测试覆盖到数个服务(整个系统)，从而导致没有一个团队需要为撰写端到端测试负责。

> In a microservices world there's also the big question of who's in charge of writing these tests. Since they span multiple services (your entire system) there's no single team responsible for writing end-to-end tests.

如果你们有一个集中的质量保障团队，看起来就适合担起这个责任。但是呢拥有一个集中化的QA团队也是一种严重的反模式，这根本不应该出现在DevOps的世界中，在这个世界里你的团队应该要真正实现跨职能。澄清谁该为端到端测试负责并不简单。也许你的组织里会有一些社区实践或者有个*质量协会*之类的能为此负责。要寻找正确答案，很大程度依赖于你的组织结构。

> If you have a centralised quality assurance team they look like a good fit. Then again having a centralised QA team is a big anti-pattern and shouldn't have a place in a DevOps world where your teams are meant to be truly cross-functional. There's no easy answer who should own end-to-end tests. Maybe your organisation has a community of practice or a *quality guild* that can take care of these. Finding the correct answer highly depends on your organisation.

而且端到端测试需要大量维护成本，运行起来还相当慢。试想一下这样的场景，除非只有几个微服务，否则你根本没办法在本地运行端到端测试，因为你需要启动所有服务。祝你的机器能跑起几百个应用，并且内存没被撑爆。

> Furthermore, end-to-end tests require a lot of maintenance and run pretty slowly. Thinking about a landscape with more than a couple of microservices in place you won't even be able to run your end-to-end tests locally — as this would require to start all your microservices locally as well. Good luck spinning up hundreds of applications on your development machine without frying your RAM.

因为其庞大的维护成本，你应该致力于减少端到端测试的数量到最低限度。

> Due to their high maintenance cost you should aim to reduce the number of end-to-end tests to a bare minimum.

考虑一下应用中对用户而言具有高价值的交互。定义好产生产品核心价值的用户旅程，然后把用户旅程变成自动化的端到端测试。

> Think about the high-value interactions users will have with your application. Try to come up with user journeys that define the core value of your product and translate the most important steps of these user journeys into automated end-to-end tests.

如果你正在构建一个电子商务页面，最具价值的顾客旅程可以是这样的：用户搜索一件商品，放进购物车然后付款。仅此而已。只要这个旅程正常工作，你应该不至于陷入太大的麻烦中。也许你可以找一两个重要且可以用端到端测试实现的用户旅程。但除此之外的话，比起提供价值，它们更多的是为你带来痛苦。

> If you're building an e-commerce site your most valuable customer journey could be a user searching for a product, putting it in the shopping basket and doing a checkout. That's it. As long as this journey still works you shouldn't be in too much trouble. Maybe you'll find one or two more crucial user journeys that you can translate into end-to-end tests. Everything more than that will likely be more painful than helpful.

谨记：在测试金字塔里，有很多低等级测试，这些测试已经全面测试了各种边缘情况，和其他系统的集成。不需要再在高层级里重复测试。高维护成本和误报错误一定会降低你的开发速度，迟早会让你失去对测试的信心。

> Remember: you have lots of lower levels in your test pyramid where you already tested all sorts of edge cases and integrations with other parts of the system. There's no need to repeat these tests on a higher level. High maintenance effort and lots of false positives will slow you down and cause you to lose trust in your tests, sooner rather than later.

#### 用户界面端到端测试

对于端到端测试来说，[Selenium](http://docs.seleniumhq.org/)和[WebDriver](https://www.w3.org/TR/webdriver/)协议是大部分开发者的选择。用Selenium你可以选一个喜欢的浏览器来自动访问网页，触发点击事件，输入数据，检查用户界面的变更。

> For end-to-end tests [Selenium](http://docs.seleniumhq.org/) and the [WebDriver](https://www.w3.org/TR/webdriver/) protocol are the tool of choice for many developers. With Selenium you can pick a browser you like and let it automatically call your website, click here and there, enter data and check that stuff changes in the user interface.

Selenium需要一个能跑测试的浏览器。有几种可以称之为*'drivers'*的浏览器可以选择。[选一种](https://www.mvnrepository.com/search?q=selenium+driver)或者几种，加到```build.gradle```里。不管你选择什么浏览器，都需要保证团队里所有开发和CI服务器都装好了对应版本的浏览器。保持同步也许相当困难。对于Java，有一个轻量级的库叫[webdrivermanager](https://github.com/bonigarcia/webdrivermanager)，它可以自动下载并设置正确版本的浏览器。把这些依赖加到```build.gradle```文件里。

> Selenium needs a browser that it can start and use for running its tests. There are multiple so-called *'drivers'* for different browsers that you could use. [Pick one](https://www.mvnrepository.com/search?q=selenium+driver) (or multiple) and add it to your ```build.gradle```. Whatever browser you choose, you need to make sure that all devs in your team and your CI server have installed the correct version of the browser locally. This can be pretty painful to keep in sync. For Java, there's a nice little library called [webdrivermanager](https://github.com/bonigarcia/webdrivermanager) that can automate downloading and setting up the correct version of the browser you want to use. Add these two dependencies to your ```build.gradle``` and you're good to go:

```
testCompile('org.seleniumhq.selenium:selenium-chrome-driver:2.53.1')
testCompile('io.github.bonigarcia:webdrivermanager:1.7.2')
```

为测试运行一个完整的浏览器有时候会是一种麻烦事。尤其对于持续交付跑Pipeline的服务器，也许没有时间打开一个包含用户界面的浏览器(例如因为当前没有可用的X-Server)。变通办法就是使用类似[xvfb](https://en.wikipedia.org/wiki/Xvfb)那样的虚拟X-Server。(看来得好好了解一下X-Server是啥，否则不翻译可能会有问题）

> Running a fully-fledged browser in your test suite can be a hassle. Especially when using continuous delivery the server running your pipeline might not be able to spin up a browser including a user interface (e.g. because there's no X-Server available). You can take a workaround for this problem by starting a virtual X-Server like [xvfb](https://en.wikipedia.org/wiki/Xvfb).

更先进一点的途径则是用*无头*浏览器(也就是没有用户界面的浏览器)来运行webdriver测试。就最近而言[PhantomJS](http://phantomjs.org/)是领先的用于浏览器自动化的无头浏览器(译者注：其实现在PhantomJS作者已经宣布停止维护了，建议转向使用[Puppeteer](https://github.com/GoogleChrome/puppeteer)）。但这之后[Chromium](https://developers.google.com/web/updates/2017/04/headless-chrome)和[Firefox](https://developer.mozilla.org/en-US/Firefox/Headless_mode)双双宣布他们在浏览器里实现了无头模式，这样来看PhantomJS就突然变得过时了。比起仅仅为了方便开发使用而人工浏览器，使用用户爱用的浏览器(像Firefox和Chrome)做测试会更好。

> A more recent approach is to use a *headless* browser (i.e. a browser that doesn't have a user interface) to run your webdriver tests. Until recently [PhantomJS](http://phantomjs.org/) was the leading headless browser used for browser automation. Ever since both [Chromium](https://developers.google.com/web/updates/2017/04/headless-chrome) and [Firefox](https://developer.mozilla.org/en-US/Firefox/Headless_mode) announced that they've implemented a headless mode in their browsers PhantomJS all of a sudden became obsolete. After all it's better to test your website with a browser that your users actually use (like Firefox and Chrome) instead of using an artificial browser just because it's convenient for you as a developer.

不管是无头Firefox还是Chrome，都是新出的东西，还没有广泛使用到实现webdriver测试中。我们想让事情保持简单。比起折腾浏览器的无头模式，我们直接用传统的Selenium和常规浏览器。一个启动Chrome，访问我们服务，检查页面内容的简单端到端测试看起来会像这样：

> Both, headless Firefox and Chrome, are brand new and yet to be widely adopted for implementing webdriver tests. We want to keep things simple. Instead of fiddling around to use the bleeding edge headless modes let's stick to the classic way using Selenium and a regular browser. A simple end-to-end test that fires up Chrome, navigates to our service and checks the content of the website looks like this:

```java
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class HelloE2ESeleniumTest {

    private WebDriver driver;

    @LocalServerPort
    private int port;

    @BeforeClass
    public static void setUpClass() throws Exception {
        ChromeDriverManager.getInstance().setup();
    }

    @Before
    public void setUp() throws Exception {
        driver = new ChromeDriver();
    }

    @After
    public void tearDown() {
        driver.close();
    }

    @Test
    public void helloPageHasTextHelloWorld() {
        driver.get(String.format("http://127.0.0.1:%s/hello", port));

        assertThat(driver.findElement(By.tagName("body")).getText(), containsString("Hello World!"));
    }
}
```

这个测试只能在你装好Chrome的系统里运行起来(本地机器，CI服务器)。

> Note that this test will only run on your system if you have Chrome installed on the system you run this test on (your local machine, your CI server).

这个测试很直白。它用```@SpringBootTest```在一个随机端口启动了整个Spring应用。然后我们实例化了一个Chrome的webdriver，告诉Chrome要去访问我们微服务的/hello路径，然后检查浏览器里是不是打印出来了"Hello World!"，看起来很酷。

> The test is straightforward. It spins up the entire Spring application on a random port using ```@SpringBootTest```. We then instantiate a new Chrome webdriver, tell it to go navigate to the /hello endpoint of our microservice and check that it prints "Hello World!" on the browser window. Cool stuff!

#### REST API 端到端测试

如果有能避开图形界面，比完整端到端测试更稳定，但是仍然能覆盖大部分应用内容的测试，那就好了。这样的话当你测试应用的用户界面十分困难时，这可就大有用处了。也许你的应用根本没有界面，仅仅是提供了REST API(也许是因为有别的应用用到这个API，也许是因为鄙视花哨的界面)。不管怎么说，[皮下测试](https://martinfowler.com/bliki/SubcutaneousTest.html)(译注：这个测试类型真是第一次见，虽然看了MF的介绍，但是也不知道怎么翻译才好)测试隐藏在图形界面背后的东西，它能给你带来极大的自信。如果你的应用也向外提供REST API，不妨来看个例子：

> Avoiding a graphical user interface when testing your application can be a good idea to come up with tests that are less flaky than full end-to-end tests while still covering a broad part of your application's stack. This can come in handy when testing through the web interface of your application is particularly hard. Maybe you don't even have a web UI but serve a REST API instead (because you have a single page application somewhere talking to that API, or simply because you despise everything that's nice and shiny). Either way, a [Subcutaneous Test](https://martinfowler.com/bliki/SubcutaneousTest.html) that tests just beneath the graphical user interface and can get you really far without compromising on confidence too much. Just the right thing if you're serving a REST API like we do in our example code:

```java
@RestController
public class ExampleController {
    private final PersonRepository personRepository;

    // shortened for clarity

    @GetMapping("/hello/{lastName}")
    public String hello(@PathVariable final String lastName) {
        Optional<Person> foundPerson = personRepository.findByLastName(lastName);

        return foundPerson
             .map(person -> String.format("Hello %s %s!",
                     person.getFirstName(),
                     person.getLastName()))
             .orElse(String.format("Who is this '%s' you're talking about?",
                     lastName));
    }
}
```

有一个库，在测试提供REST API的服务时很好用。[REST-assured](https://github.com/rest-assured/rest-assured) ，它是个可以让你优雅地发出真实HTTP请求并检验响应的库。

> Let me show you one more library that comes in handy when testing a service that provides a REST API. [REST-assured](https://github.com/rest-assured/rest-assured) is a library that gives you a nice DSL for firing real HTTP requests against an API and evaluating the responses you receive.

第一件事，把这个库加到```build.gradle```里。

> First things first: Add the dependency to your ```build.gradle```.

```testCompile('io.rest-assured:rest-assured:3.0.3')```

用这个库，我们能这样实现我们针对REST API的端到端测试：

> With this library at our hands we can implement an end-to-end test for our REST API:

```java
@RunWith(SpringRunner.class)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
public class HelloE2ERestTest {

    @Autowired
    private PersonRepository personRepository;

    @LocalServerPort
    private int port;

    @After
    public void tearDown() throws Exception {
        personRepository.deleteAll();
    }

    @Test
    public void shouldReturnGreeting() throws Exception {
        Person peter = new Person("Peter", "Pan");
        personRepository.save(peter);

        when()
                .get(String.format("http://localhost:%s/hello/Pan", port))
        .then()
                .statusCode(is(200))
                .body(containsString("Hello Peter Pan!"));
    }
}
```

再说一遍，我们用```@SpringBootTest```启动完整的Spring应用。这里面我们用对```PersonRepository```用```@Autowire```，所以我们能很容易把数据写到数据库里。当我们用API请求，对Mr Pan打招呼说hello时，我们将会收到一个完整的打招呼响应(Hello Peter Pan!)。就这么简单！如果你的应用没有用户界面，那么这个端到端测试绰绰有余。

> Again, we start the entire Spring application using ```@SpringBootTest```. In this case we ```@Autowire``` the ```PersonRepository``` so that we can write test data into our database easily. When we now ask the REST API to say "hello" to our friend "Mr Pan" we're being presented with a nice greeting. Amazing! And more than enough of an end-to-end test if you don't even sport a web interface.

## 验收测试——你的功能在正常工作吗？

测试金字塔越往上，越有可能需要从用户的角度来测试你所构建的功能是否能正常工作。你可以把应用视为黑盒，然后把测试关注点从这样的方式：

> The higher you move up in your test pyramid the more likely you enter the realms of testing whether the features you're building work correctly from a user's perspective. You can treat your application as a black box and shift the focus in your tests from

当我输入x和y的值，返回值应该是z

> when I enter the values x and y, the return value should be z

转变为：

> towards

在用户登陆了的情况下

> given there's a logged in user

有一篇名为“bicycle”的文章

> and there's an article "bicycle"

用户进入“bicycle”这篇文章的详情页面

> when the user navigates to the "bicycle" article's detail page

点击“添加到购物篮”

> and clicks the "add to basket" button

然后“bicycle”这篇文章应该在用户的购物篮里

> then the article "bicycle" should be in their shopping basket

对于这样的测试，有时候你会听到像[功能性测试](https://en.wikipedia.org/wiki/Functional_testing)或者[验收测试](https://en.wikipedia.org/wiki/Acceptance_testing#Acceptance_testing_in_extreme_programming)这样的说法。偶尔会有人跟你说功能性和验收测试不是一回事。偶尔这些说法却又是一回事。人们可能对这些说法和定义陷入无尽的争论。这样的的套路经常会成为混乱源头。

> Sometimes you'll hear the terms [functional test](https://en.wikipedia.org/wiki/Functional_testing) or [acceptance test](https://en.wikipedia.org/wiki/Acceptance_testing#Acceptance_testing_in_extreme_programming) for these kinds of tests. Sometimes people will tell you that functional and acceptance tests are different things. Sometimes the terms are conflated. Sometimes people will argue endlessly about wording and definitions. Often this discussion is a pretty big source of confusion.

其实是这样的：在一个方面你必须保证不是从技术角度，而是从*用户*角度测试了软件是正常工作的。你怎么称呼这种测试并不重要。为了这些测试，选一个说法(功能性测试也好，验收测试也罢)，然后开始撰写。

> Here's the thing: At one point you should make sure to test that your software works correctly from a *user's* perspective, not just from a technical perspective. What you call these tests is really not that important. Having these tests, however, is. Pick a term, stick to it, and write those tests.

这也是人们时常说到的BDD，以及允许你用BDD来实现测试的工具。BDD或者BDD方式写出来的测试可以较为容易地把你的思维从实现细节转向用户需要。那么接下来我们来试一试。

> This is also the moment where people talk about BDD and tools that allow you to implement tests in a BDD fashion. BDD or a BDD-style way of writing tests can be a nice trick to shift your mindset from implementation details towards the users' needs. Go ahead and give it a try.

你甚至不需要采用已经十分成熟的BDD工具，例如[Cucumber](https://cucumber.io/)(虽然你也可以用)。断言库(就像[chai.js](http://chaijs.com/guide/styles/#should))会让你用```should```这类让测试读起来更像BDD方式的关键字去书写断言。即便你不用这样的库，优美并且精巧的代码也能写出专注于用户行为的测试。一些小巧的helper方法/函数就能让你做到这一点：

> You don't even need to adopt full-blown BDD tools like [Cucumber](https://cucumber.io/) (though you can). Some assertion libraries (like [chai.js](http://chaijs.com/guide/styles/#should) allow you to write assertions with ```should```-style keywords that can make your tests read more BDD-like. And even if you don't use a library that provides this notation, clever and well-factored code will allow you to write user behaviour focused tests. Some helper methods/functions can get you a very long way:

```python
# 一个用Python写的验收测试示例

def test_add_to_basket():
    # given
    user = a_user_with_empty_basket()
    user.login()
    bicycle = article(name="bicycle", price=100)

    # when
    article_page.add_to_.basket(bicycle)

    # then
    assert user.basket.contains(bicycle)
```

验收测试可以来自不同粒度的层次。大部分的时候它们处于相当高级别，直接从用户界面去测试服务。然而，最好理解从技术上看没有必要在测试金字塔最高处书写验收测试。如果应用设计和场景允许你在低层级写验收测试，那就这样做。把它写成低层级测试要比写成高层级测试好。验收测试的概念(证明在用户来看，应用是正常工作的)是和测试金字塔完全契合的。

> Acceptance tests can come in different levels of granularity. Most of the time they will be rather high-level and test your service through the user interface. However, it's good to understand that there's technically no need to write acceptance tests at the highest level of your test pyramid. If your application design and your scenario at hand permits that you write an acceptance test at a lower level, go for it. Having a low-level test is better than having a high-level test. The concept of acceptance tests - proving that your features work correctly for the user - is completely orthogonal to your test pyramid.

## 探索测试

即便是最勤奋的自动化测试，它也不是完美的。偶尔你会在自动化测试里漏掉一些边缘情况。偶尔会出现近乎不可能在单元测试里检测出特定bug。在自动化测试中，某些质量问题甚至不明显(考虑到设计或者可用性)。即使对自动化测试抱着崇高的希望，但是对某些场景的手工测试也是不可避免的。

> Even the most diligent test automation efforts are not perfect. Sometimes you miss certain edge cases in your automated tests. Sometimes it's nearly impossible to detect a particular bug by writing a unit test. Certain quality issues don't even become apparent within your automated tests (think about design or usability). Despite your best intentions with regards to test automation, manual testing of some sorts is still a good idea.

![图12](https://martinfowler.com/articles/practical-test-pyramid/exploratoryTesting.png)

*图12： 用户探索性测试揪出自动化构建流水线上没有能发现的问题*

*Figure 12: Use exploratory testing to spot all quality issues that your build pipeline didn't spot*

把[探索性测试](https://en.wikipedia.org/wiki/Exploratory_testing) 纳入测试组合里。这是一种强调测试者自由发挥，创造性操作来发掘运行系统中问题的一类手工测试。定期花点时间，捋起袖子去尝试破坏应用，使其不能正常工作。用破坏性思维，想象能破坏应用的方式。然后为了未来记录下一切你发现的东西。注意bug们，设计问题，慢响应次数，缺失的或者误导性的错误信息，甚至任何会让作为用户的你感到恼怒的东西。

> Include [Exploratory Testing](https://en.wikipedia.org/wiki/Exploratory_testing) in your testing portfolio. It is a manual testing approach that emphasises the tester's freedom and creativity to spot quality issues in a running system. Simply take some time on a regular schedule, roll up your sleeves and try to break your application. Use a destructive mindset and come up with ways to provoke issues and errors in your application. Document everything you find for later. Watch out for bugs, design issues, slow response times, missing or misleading error messages and everything else that would annoy you as a user of your software.

如果你能很快自动化大部分你发现的东西，这当然是好事。为这些bug们书写自动化测试确保了日后不必为这些bug做回归。并且它能帮你缩小你在修复bug时，bug产生原因的范围。

> The good news is that you can happily automate most of your findings with automated tests. Writing automated tests for the bugs you spot makes sure there won't be any regressions of that bug in the future. Plus it helps you narrowing down the root cause of that issue during bugfixing.

在探索性测试时，你可以发现被构建流水线错过的问题。不要失望，这是关于流水线成熟度的反馈。根据这些反馈可以试图这样想：做点什么才能这类问题在未来发生。也许是缺失了某一类自动化测试。也许是这个迭代的自动化测试做得马马虎虎，需要测试得更为透彻。也许有好用的新工具或者途径可以让你的流水线日后避开这类问题。记住这种思考方式，这样你的流水线，你的软件交付将随着时间推移变得越来越成熟。

> During exploratory testing you will spot problems that slipped through your build pipeline unnoticed. Don't be frustrated. This is great feedback on the maturity of your build pipeline. As with any feedback, make sure to act on it: Think about what you can do to avoid these kinds of problems in the future. Maybe you're missing out on a certain set of automated tests. Maybe you have just been sloppy with your automated tests in this iteration and need to test more thoroughly in the future. Maybe there's a shiny new tool or approach that you could use in your pipeline to avoid these issues in the future. Make sure to act on it so your pipeline and your entire software delivery will grow more mature the longer you go.

## 测试术语的困惑

讨论不同测试的分类很难。我的意思是当我说单元测试的时候，可能会跟你想象的有些出入。对于集成测试而言，可能分歧会更大。一些人觉得集成测试应该是非常大的，能测试到系统中很多个方面。对我而言则是个很狭隘的东西，一次仅测试和外部集成的一小块。有些人称它们为*集成测试*，另一些人更喜欢称它们为*组件测试*，还有些人喜欢称为*服务测试*。即便有人会为此争吵，觉得这三个术语是完全不同的东西。但这无关对错。软件开发社区没办法给出测试术语的明确定义。

> Talking about different test classifications is always difficult. What I mean when I talk about unit tests can be slightly different from your understanding. With integration tests it's even worse. For some people integration testing is a very broad activity that tests through a lot of different parts of your entire system. For me it's a rather narrow thing, only testing the integration with one external part at a time. Some call them *integration tests*, some refer to them as *component tests*, some prefer the term *service test*. Even others will argue, that all of these three terms are totally different things. There's no right or wrong. The software development community simply hasn't managed to settle on well-defined terms around testing.

不必孜孜不倦地去研讨带有歧义的术语。你把测试称为端到端测试也好，广域栈测试也罢，功能性测试也行，都没问题。你认为的集成测试和其他公司的人想法有很大不同也没关系。是的，如果以我们的专业性能定义出术语们明确的边界并且广为人知，这将是一件美妙的事。不幸的是这件事并没有发生。而且在编写测试时会有很多细微差别，它们的范围是互相重叠而不是离散的，这使得保持术语们的一致性命名更为艰难。

> Don't get too hung up on sticking to ambiguous terms. It doesn't matter if you call it end-to-end or broad stack test or functional test. It doesn't matter if your integration tests mean something different to you than to the folks at another company. Yes, it would be really nice if our profession could settle on some well-defined terms and all stick to it. Unfortunately this hasn't happened yet. And since there are many nuances when it comes to writing tests it's really more of a spectrum than a bunch of discrete buckets anyways, which makes consistent naming even harder.

更重要的事情是，你应该找到适合你和你团队的术语。清晰理解你想写的不同类别测试。团队要在测试命名上保持统一，并且为每一类测试划分清晰的范围。你真的应该关心的是能在团队内保持一致(甚至能上升到组织内一致)。[Simon Stewart](https://testing.googleblog.com/2010/12/test-sizes.html)在描述他们在Google里使用的办法时，总结得很精妙。这篇文章展示了如何避免过于依赖名称和命名习惯所带来的麻烦。

> The important takeaway is that you should find terms that work for you and your team. Be clear about the different types of tests that you want to write. Agree on the naming in your team and find consensus on the scope of each type of test. If you get this consistent within your team (or maybe even within your organisation) that's really all you should care about. [Simon Stewart](https://testing.googleblog.com/2010/12/test-sizes.html) summed this up very nicely when he described the approach they use at Google. And I think it shows perfectly how getting too hung up on names and naming conventions just isn't worth the hassle.

## 把测试放到你的部署流水线上

如果你正在践行持续集成或者持续交付的实践，那么你会有一条[部署流水线](https://martinfowler.com/bliki/DeploymentPipeline.html)来就每一次改动运行自动化测试。通常这个流水线会被分成几级，以此让你逐渐建立起把软件部署到生产环境的自信。听到所有这些不同类型的测试，你可能想知道应该把它们放在部署流水线中的什么地方。要找到答案，你可以考虑一下持续交付带来的一个很基础的价值(实际上是[极限编程](http://www.extremeprogramming.org/values.html)和敏捷开发带来的核心价值之一)：**快速反馈**

> If you're using Continuous Integration or Continuous Delivery, you'll have a [Deployment Pipeline](https://martinfowler.com/bliki/DeploymentPipeline.html) in place that will run automated tests every time you make a change to your software. Usually this pipeline is split into several stages that gradually give you more confidence that your software is ready to be deployed to production. Hearing about all these different kinds of tests you're probably wondering how you should place them within your deployment pipeline. To answer this you should just think about one of the very foundational values of Continuous Delivery (indeed one of the core [values of Extreme Programming](http://www.extremeprogramming.org/values.html) and agile software development): **Fast Feedback**.

## 避免测试重复

现在你已经清楚了要为软件编写不同类型的测试，但是这还有一个陷阱你需要避开：贯穿金字塔不同层级的重复测试。虽然你本能会说并没有那么多测试，但我向你保证事实如此。测试组合中每一个测试都是需要付出的，并不是免费的。撰写和维护这些测试要消耗时间。阅读和理解其他人写的测试也会花时间。当然，运行这些测试也要费时间。

> Now that you know that you should write different types of tests there's one more pitfall to avoid: duplicating tests throughout the different layers of the pyramid. While your gut feeling might say that there's no such thing as too many tests let me assure you, there is. Every single test in your test suite is additional baggage and doesn't come for free. Writing and maintaining tests takes time. Reading and understanding other people's test takes time. And of course, running tests takes time.

对于产品代码，你应该力争简单杜绝重复。在实现测试金字塔的背景下，你应该牢记这俩经验法则：

> As with production code you should strive for simplicity and avoid duplication. In the context of implementing your test pyramid you should keep two rules of thumb in mind:

1. 如果一个高层测试发现了一个错误并且底层测试全都通过了，你应该写一个低层级测试去覆盖这个错误。
2. 竭尽所能把测试往金字塔下层赶。

> 1. If a higher-level test spots an error and there's no lower-level test failing, you need to write a lower-level test
> 2. Push your tests as far down the test pyramid as you can

第一条法则很重要，这是因为低层级测试让你更容易缩小错误范围，并且隔离掉大部分上下文把错误重现。在调试手头上的问题时，低层级测试运行起来更快，而且一点都不臃肿。并且这些测试也能作为回归测试服务于将来。第二条法则对于保持测试组合的高效很重要。如果你在低层级测试里覆盖了所有情况，那么就不必维护一个高层级的测试。因为这并不能给你就软件正常工作带来更多的自信。如果日常里有无效的测试，那很让人恼火。测试组合会因此拖慢节奏，这样的话当你改变代码行为时就需要改更多测试。

> The first rule is important because lower-level tests allow you to better narrow down errors and replicate them in an isolated way. They'll run faster and will be less bloated when you're debugging the issue at hand. And they will serve as a good regression test for the future. The second rule is important to keep your test suite fast. If you have tested all conditions confidently on a lower-level test, there's no need to keep a higher-level test in your test suite. It just doesn't add more confidence that everything's working. Having redundant tests will become annoying in your daily work. Your test suite will be slower and you need to change more tests when you change the behaviour of your code.

让我们尝试用不同方式说：如果高层级测试能就软件正常工作带来更多自信，你应该留着它。给一个Controller类写单元测试可以测试Controller类自己的逻辑。然而，它没告诉你这个Controller提供的REST路径真正响应了HTTP请求。所以你写了一个高层级的测试来测试它是否能正常响应请求，仅此而已。不需要测试所有条件分支和边缘场景，因为低层级测试已经覆盖到了。保证高层级测试仅仅关注低层级测试覆盖不到的地方。

> Let's phrase this differently: If a higher-level test gives you more confidence that your application works correctly, you should have it. Writing a unit test for a Controller class helps to test the logic within the Controller itself. Still, this won't tell you whether the REST endpoint this Controller provides actually responds to HTTP requests. So you move up the test pyramid and add a test that checks for exactly that - but nothing more. You don't test all the conditional logic and edge cases that your lower-level tests already cover in the higher-level test again. Make sure that the higher-level test focuses on the part that the lower-level tests couldn't cover.

我对于不再提供价值的测试很严格，必须消灭掉它们。我会删掉已经被低层级测试覆盖完全的高层级测试(假设它没在提供额外价值了)。我尽可能用低层级测试取代高层级测试。有时候，这会有些困难，尤其是你知道设计测试本身就很艰难的情况下。警惕沉没成本谬误(译者注：[沉没成本](https://zh.wikipedia.org/wiki/%E6%B2%89%E6%B2%A1%E6%88%90%E6%9C%AC)是一个经济学概念，沉没成本谬误在这里指的是不忍删除花了时间精力撰写的测试)，果断摁下删除键。没有理由为不再提供价值的测试上浪费宝贵时间。

> I'm rigorous when it comes to eliminating tests that don't provide any value. I delete high-level tests that are already covered on a lower level (given they don't provide extra value). I replace higher-level tests with lower-level tests if possible. Sometimes that's hard, especially if you know that coming up with a test was hard work. Beware of the sunk cost fallacy and hit the delete key. There's no reason to waste more precious time on a test that ceased to provide value.

## 整洁测试代码

和写代码一样，写好良好整洁的测试代码也很重要。在你在自动化测试之路上继续前进之前，我有些写可维护测试代码的窍门想告诉你：

> As with writing code in general, coming up with good and clean test code takes great care. Here are some more hints for coming up with maintainable test code before you go ahead and hack away on your automated test suite:

1. 测试代码跟生产代码一样重要。要对它们赋予同等的关注和照顾。并不能用*“这只是测试代码”*作为借口来给邋遢代码辩解。
2. 一个测试只测试一种情况。这能帮你的测试保持短小，容易阅读。
3. *“arrange, act, assert”*或者*“given, when, then”*是让你写出良好结构测试的助记符。
4. 可读性很重要。不要过于追求DRY。如果能提高可读性，重复有时候也是可以接受的。请在[DRY和DAMP](https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests)之间寻找好平衡。
5. 当你产生疑惑时，试试用[Rule of Three](https://blog.codinghorror.com/rule-of-three/)来决定是不是要重构。*重复使用这个规则*

> 1. Test code is as important as production code. Give it the same level of care and attention. *"this is only test code"* is not a valid excuse to justify sloppy code
> 2. Test one condition per test. This helps you to keep your tests short and easy to reason about
> 3. *"arrange, act, assert"* or *"given, when, then"* are good mnemonics to keep your tests well-structured
> 4. Readability matters. Don't try to be overly DRY. Duplication is okay, if it improves readability. Try to find a balance between [DRY and DAMP](https://stackoverflow.com/questions/6453235/what-does-damp-not-dry-mean-when-talking-about-unit-tests) code
> 5. When in doubt use the [Rule of Three](https://blog.codinghorror.com/rule-of-three/) to decide when to refactor. *Use before reuse*

## 结论

好了！我知道这是一篇非常漫长并且艰难的文章，这篇文章解释了为什么以及如何测试软件。好消息是，这篇文章提供的信息经得起时间推敲，并且可以独立于你构建的软件而存在。不管你是工作在微服务下，还是IoT设备上，抑或是手机应用或者网页应用，这篇文章或多或少都有些契合点可供参考。

> That's it! I know this was a long and tough read to explain why and how you should test your software. The great news is that this information is pretty timeless and independent of what kind of software you're building. It doesn't matter if you're working on a microservices landscape, IoT devices, mobile apps or web applications, the lessons from this article can be applied to all of these.

我希望这篇文章有些东西对你是有用的。现在继续往前，去[示例代码](https://github.com/hamvocke/spring-testing)看看，把这里介绍的一些概念纳入到你的测试组合中。想拥有一套稳固的测试组合确实需要付出努力。长远来看，这种测试组合会给你回报的，它们也会给你带来更多清静，相信我。

> I hope that there's something useful in this article. Now go ahead and check out the [sample code](https://github.com/hamvocke/spring-testing) and get some of the concepts explained here into your testing portfolio. Having a solid test portfolio takes some effort. It will pay off in the longer term and it will make your live as a developer more peaceful, trust me.

### 致谢

感谢Clare Sudbery, Chris Ford, Martha Rohte, Andrew Jones-Weiss David Swallow, Aiko Klostermann, Bastian Stein, Sebastian Roidl and Birgitta Böckeler在本文初期时提供的反馈和建议。感谢Martin Fowler的建议，想法和支持。

> Thanks to Clare Sudbery, Chris Ford, Martha Rohte, Andrew Jones-Weiss David Swallow, Aiko Klostermann, Bastian Stein, Sebastian Roidl and Birgitta Böckeler for providing feedback and suggestions to early drafts of this article. Thanks to Martin Fowler for his advice, insights and support.


