### 测试金字塔实战
> The Practical Test Pyramid

“测试金字塔”是一个比喻，它告诉我们要把软件测试按照不同粒度来分组。它也给出了在这些分组中每个组应该有多少测试的看法。虽然测试金字塔的概念已经存在了一段时间，但一些团队仍然很难正确将它投入实践。本文重新审视“测试金字塔”最初的概念，并展示如何将其付诸实践。它展示了你应该在金字塔的不同层次上寻找何种类型的测试，并给出了如何实现这些测试的实例。

> The "Test Pyramid" is a metaphor that tells us to group software tests into buckets of different granularity. It also gives an idea of how many tests we should have in each of these groups. Although the concept of the Test Pyramid has been around for a while, teams still struggle to put it into practice properly. This article revisits the original concept of the Test Pyramid and shows how you can put this into practice. It shows which kinds of tests you should be looking for in the different levels of the pyramid and gives practical examples on how these can be implemented.

2018年2月26日

> 26 February 2018

作者：Ham Vocke

> Ham Vocke

Ham是德国ThoughtWorks的一名软件开发和咨询师。由于厌倦了在凌晨3点手动部署软件，他开始持续交付实践，加紧自动化步伐，并着手帮助团队高效可靠地交付高质量软件。他用优雅的表现填补了恼人的时间。

> Ham is a software developer and consultant at ThoughtWorks in Germany. Being tired of deploying software manually at 3 a.m., he added continuous delivery and diligent automation to his toolbox and set out to help teams deliver high-quality software reliably and efficiently. He makes up for the time gained by annoying people with his antics.

###### 目录
测试自动化的重要性

测试金字塔

我们用到的工具和库

应用例子

- 功能

- 整体架构

- 内部架构

单元测试

- 什么是单元？

- 社交和独处

- 仿造和打桩(Mocking and Stubbing)（TODO：这种技术术语的翻译是啥？）

- 测试什么？

- 测试架构

- 实现一个单元测试

集成测试

- 数据库集成

- REST API 集成

- 几个独立服务的集成

- JSON的解析和撰写

契约测试

- 消费者测试(我们团队)

- 提供者测试(其他团队)

- 提供者测试(我们团队)

UI测试

端到端测试

- 用户界面端到端测试

- REST API 端到端测试

验收测试 - 你的功能可以正常使用吗？

探索性测试

对测试术语的误解

把测试放到部署流水线

避免重复测试

对写测试的建议

总结

有时候我真的想测试私有方法

> ##### Contents

> The Importance of (Test) Automation

> The Test Pyramid

> Tools and Libraries We'll Look at

> The Sample Application

> - Functionality

> - High-level Structure

> - Internal Architecture

> Unit tests

> - What's a Unit?

> - Sociable and Solitary

> - Mocking and Stubbing

> - What to Test?

> - Test Structure

> - Implementing a Unit Test

> Integration Tests

> - Database Integration

> - Integration With Separate Services

> Contract Tests

> - Consumer Test (our team)

> - Provider Test (the other team)

> - Provider Test (our team)

> UI Tests

> End-to-End Tests

> - User Interface End-to-End Test

> - REST API End-to-End Test

> Acceptance Tests — Do Your Features Work Correctly?

> Exploratory Testing

> The Confusion About Testing Terminology

> Putting Tests Into Your Deployment Pipeline

> Avoid Test Duplication

> Writing Clean Test Code

> Conclusion

> ##### Sidebars

> But I Really Need to Test This Private Method

> Specialised Test Helpers

![](https://martinfowler.com/articles/practical-test-pyramid/teaser.png)

准备上生产环境的软件在上生产之前需要进行测试。随着软件开发行业的成熟，软件测试方法也日趋成熟。开发团队正在逐渐自动化大部分的测试，而不是依赖于大量的测试人员来进行手工测试。通过自动化测试，开发团队可以几秒钟就知道他们的软件是否被破坏，而不是几天后才知道。

> Production-ready software requires testing before it goes into production. As the discipline of software development matured, software testing approaches have matured too. Instead of having myriads of manual software testers development teams have moved towards automating the biggest portion of their testing efforts. Automating your test efforts allows teams to know whether their software is broken in a matter of seconds and minutes instead of days and weeks.

自动化测试极大地缩短了反馈周期，这与敏捷开发实践、持续集成、DevOps 文化等是一脉相承的。拥有高效的软件测试方法，可以让你的团队快速而自信地前行。

> The drastically shortened feedback loop fuelled by automated tests goes hand in hand with agile development practices, continuous delivery and DevOps culture. Having an effective software testing approach allows your team to move fast and confidently.

本文将探讨一个具备高响应力的、可靠并且可维护的测试组合应该如何构建，这与你具体构建的是一个微服务架构、移动应用程序或者物联网生态系统都无关。此外，我们还将详细介绍如何写出高效且可读的自动化测试。

> This article explores what a well-rounded test portfolio should look like to be responsive, reliable and maintainable - regardless of whether you're building a microservices architecture, mobile apps or IoT ecosystems. We'll also get into the details of building effective and readable automated tests.

#### （测试）自动化的重要性

软件已经成为我们日常生活中的一个重要组成部分。早期它仅仅用于提高企业的效率，但如今它的作用远不止如此。如今许多公司都想方设法成为一流的数字化公司。作为用户，我们每天使用的软件越来越多。创新的车轮正越转越快。

> Software has become an essential part of the world we live in. It has outgrown its early sole purpose of making businesses more efficient. Today companies try to find ways to become first-class digital companies. As users everyone of us interacts with an ever-increasing amount of software every day. The wheels of innovation are turning faster.

如果你想跟上时代的步伐，你必须研究如何在不牺牲质量的情况下更快地交付你的软件。持续交付——一种高度自动化的、确保你可以随时将软件发布到生产环境中的实践——正能帮你达到这个目的。它也可以通过构建流水线自动测试你的软件并将其部署到测试和生产环境中。

> If you want to keep pace you'll have to look into ways to deliver your software faster without sacrificing its quality. Continuous delivery, a practice where you automatically ensure that your software can be released into production any time, can help you with that. With continuous delivery you use a build pipeline to automatically test your software and deploy it to your testing and production environments.

软件的数量正以前所未有的速度增长，如果还是手动进行构建、测试和部署，很快就会变得不可能了——除非你想把所有的时间都用来进行手动重复的工作，而不是用来开发可工作的软件。将一切自动化——从构建到测试，从部署到基础架构——是你唯一的出路。

> Building, testing and deploying an ever-increasing amount of software manually soon becomes impossible — unless you want to spend all your time with manual, repetitive work instead of delivering working software. Automating everything — from build to tests, deployment and infrastructure — is your only way forward.

![图1](https://martinfowler.com/articles/practical-test-pyramid/buildPipeline.png)

*图1：使用构建流水线来自动并可靠地将你的软件部署到生产环境*

> Figure 1: Use build pipelines to automatically and reliably get your software into production

传统的软件测试过于依赖手工操作：你首先将应用程序部署到测试环境后，然后执行一些黑盒测试，例如，通过点击用户界面来查看一切是否工作如常。通常这些测试将由文档指定，以确保测试人员每次测试的内容是一致的。

> Traditionally software testing was overly manual work done by deploying your application to a test environment and then performing some black-box style testing e.g. by clicking through your user interface to see if anything's broken. Often these tests would be specified by test scripts to ensure the testers would do consistent checking.

很明显，手动测试所有更改非常耗时、重复而且繁琐。重复很无趣，无趣就容易犯错，这样还没测到周末结束你就会想找下一份工作了。

> It's obvious that testing all changes manually is time-consuming, repetitive and tedious. Repetitive is boring, boring leads to mistakes and makes you look for a different job by the end of the week.

幸运的是，重复性劳动还是有药可治的：自动化。

> Luckily there's a remedy for repetitive tasks: automation.

自动化繁琐重复的测试将给软件开发人员的生活带来重大改变。自动化这些测试后，你就不需要再一味遵循测试文档点点点以确保软件是否仍正常工作。自动化这些测试，你可以充满自信地修改你的代码。如果你曾试过在没有适当自动化测试的情况下进行大规模的重构，那你应该知道这种体验多么恐怖。你怎么知道你有否意外地破坏了某些功能呢？显然，你需要将所有的测试用例手动点一遍。不过老实说，你真的享受这个过程吗？你想象一下，如果你对代码做了大规模改动后惬意地喝了一口咖啡，喝完咖啡后你能马上得知你的改动有没有破坏原有功能。这样的开发体验是不是听起来就让人舒服多了？

> Automating your repetitive tests can be a big game changer in your life as a software developer. Automate these tests and you no longer have to mindlessly follow click protocols in order to check if your software still works correctly. Automate your tests and you can change your codebase without batting an eye. If you've ever tried doing a large-scale refactoring without a proper test suite I bet you know what a terrifying experience this can be. How would you know if you accidentally broke stuff along the way? Well, you click through all your manual test cases, that's how. But let's be honest: do you really enjoy that? How about making even large-scale changes and knowing whether you broke stuff within seconds while taking a nice sip of coffee? Sounds more enjoyable if you ask me.

#### 测试金字塔

如果你真的想为你的软件构建自动化测试，你必须知道一个关键的概念：测试金字塔。Mike Cohn在他的着作《Succeeding with Agile》一书中提出了这个概念。这个比喻非常形象，它让你一眼就知道测试是需要分层的。它还告诉你每一层需要写多少测试。

> If you want to get serious about automated tests for your software there is one key concept you should know about: the test pyramid. Mike Cohn came up with this concept in his book Succeeding with Agile. It's a great visual metaphor telling you to think about different layers of testing. It also tells you how much testing to do on each layer.

![图2](https://martinfowler.com/articles/practical-test-pyramid/testPyramid.png)

*图2：测试金字塔*

根据Mike Cohn的测试金字塔，你的测试组合应该由以下三层组成（自下往上分别是）：

- 单元测试
- 服务测试
- 用户界面测试

> Mike Cohn's original test pyramid consists of three layers that your test suite should consist of (bottom to top):

> - Unit Tests
> - Service Tests
> - User Interface Tests

不幸的是，如果你仔细思考就会发现，测试金字塔的概念有点太短了。有人认为，Mike Cohn的测试金字塔里的命名或某些概念不是最理想的。我也同意这一点。从当今的角度来看，测试金字塔似乎过于简单了，因此可能会产生误导。

> Unfortunately the concept of the test pyramid falls a little short if you take a closer look. Some argue that either the naming or some conceptual aspects of Mike Cohn's test pyramid are not ideal, and I have to agree. From a modern point of view the test pyramid seems overly simplistic and can therefore be misleading.

然而，由于其简洁性，在建立你自己的测试组合时，测试金字塔本身是一条很好的经验法则。你最好是记住Cohn测试金字塔中提到的两件事：

- 编写不同粒度的测试
- 层次越高，你写的测试应该越少

> Still, due to it's simplicity the essence of the test pyramid serves as a good rule of thumb when it comes to establishing your own test suite. Your best bet is to remember two things from Cohn's original test pyramid:

> - Write tests with different granularity
> - The more high-level you get the fewer tests you should have

为了维持金字塔形状，一个健康、快速、可维护的测试组合应该是这样的：写许多小而快的单元测试。适当写一些更粗粒度的测试，写很少高层次的端到端测试。注意不要让你的测试变成[冰淇淋](https://www.thoughtworks.com/insights/blog/introducing-software-testing-cupcake-anti-pattern)那样子，这对维护来说将是一个噩梦，并且跑一遍也需要太多时间。

> Stick to the pyramid shape to come up with a healthy, fast and maintainable test suite: Write lots of small and fast unit tests. Write some more coarse-grained tests and very few high-level tests that test your application from end to end. Watch out that you don't end up with a test ice-cream cone that will be a nightmare to maintain and takes way too long to run.

不要太拘泥于Cohn测试金字塔中各层次的名字。事实上，它们可能相当具有误导性：服务测试是一个难以掌握的术语（Cohn本人说他观察到[很多开发人员完全忽略了这一层](https://www.mountaingoatsoftware.com/blog/the-forgotten-layer-of-the-test-automation-pyramid)）。在单页应用框架（如react，angular，ember.js等）的时代，UI测试显然不必位于金字塔的最高层，你完全能够用这些框架对UI进行单元测试。

> Don't become too attached to the names of the individual layers in Cohn's test pyramid. In fact they can be quite misleading: service test is a term that is hard to grasp (Cohn himself talks about the observation that a lot of developers completely ignore this layer). In the days of single page application frameworks like react, angular, ember.js and others it becomes apparent that UI tests don't have to be on the highest level of your pyramid - you're perfectly able to unit test your UI in all of these frameworks.

考虑到原始名称的缺点，只要在你的代码库和团队讨论中达成一致，你完全可以为测试层次提供其他名称。

> Given the shortcomings of the original names it's totally okay to come up with other names for your test layers, as long as you keep it consistent within your codebase and your team's discussions.

#### 我们将使用的工具和库

- [JUnit](http://junit.org/junit5/): 测试执行库
- [Mockito](http://site.mockito.org/): 仿造(mock)依赖
- [Wiremock](http://wiremock.org/): 隔离外部服务
- MockMVC: 编写 HTTP 集成测试（需要补充链接）
- [Pact](https://docs.pact.io/): 用于编写消费者驱动的契约测试
- [Selenium](http://docs.seleniumhq.org/): 用于编写用户界面驱动的端到端测试
- [REST-assured](https://github.com/rest-assured/rest-assured): 用于编写REST API驱动的端到端测试

> - JUnit: our test runner
> - Mockito: for mocking dependencies
> - Wiremock: for stubbing out external services
> - MockMVC: for writing HTTP integration tests
> - Pact: for writing CDC tests
> - Selenium: for writing UI-driven end-to-end tests
> - REST-assured: for writing REST API-driven end-to-end tests

#### 示例应用

我已经写好了一个[简单的微服务应用](https://github.com/hamvocke/spring-testing)，其中涵盖了测试金字塔各种层次的测试。

> I've written a simple microservice including a test suite with tests for the different layers of the test pyramid.

示例应用体现了一个典型的微服务的特点。它提供了一个REST接口，与数据库进行通信并从第三方REST服务中获取信息。它是使用Spring Boot实现的，即使你之前从未使用过Spring Boot，它也简单到应该可以理解。

> The sample application shows traits of a typical microservice. It provides a REST interface, talks to a database and fetches information from a third-party REST service. It's implemented in Spring Boot and should be understandable even if you've never worked with Spring Boot before.

请下载Github上的代码。Readme里写了你在计算机上运行应用程序及其自动化测试所需的说明。

> Make sure to check out the code on Github. The readme contains instructions you need to run the application and its automated tests on your machine.

##### 功能

应用的功能十分简单。它提供了三个REST接口：

- ```GET /hello```	总是返回"Hello World"
	 ```GET /hello/{lastname}```	根据lastname来查询人，如果查到了结果将返回"Hello {Firstname} {Lastname}"
	 ```GET /weather```	返回现在德国汉堡的天气情况

> The application's functionality is simple. It provides a REST interface with three endpoints:

> - ```GET /hello```	Returns "Hello World". Always.
> 	 ```GET /hello/{lastname}```	Looks up the person with the provided last name. If the person is known, returns "Hello {Firstname} {Lastname}".
> 	 ```GET /weather```	Returns the current weather conditions for Hamburg, Germany.

##### 高层架构

从高层次来看，这个系统的结构是这样：

> On a high-level the system has the following structure:

![图3](https://martinfowler.com/articles/practical-test-pyramid/testService.png)

*图3：我们微服务系统的高层架构*

我们的微服务提供了一个可以通过HTTP调用的REST接口。对于某些接口，服务将从数据库获取信息。在其他情况下，服务将通过HTTP调用外部[天气API](https://darksky.net/forecast/40.7127,-74.0059/us12/en)来获取并显示当前天气状况。

> Our microservice provides a REST interface that can be called via HTTP. For some endpoints the service will fetch information from a database. In other cases the service will call an external weather API via HTTP to fetch and display current weather conditions.

##### 内部架构

在内部，Spring Service有一个典型的Spring架构：

> Internally, the Spring Service has a Spring-typical architecture:

![图4](https://martinfowler.com/articles/practical-test-pyramid/testArchitecture.png)

*图4：我们微服务的内部架构*

- ```Controller``` 提供REST接口，处理HTTP请求和响应
- ```Repository``` 和数据库打交道，关注数据在持久化存储里的读写操作
- ```Client``` 和别的API交互，在我们的应用里它会通过HTTPS从darksky.net获取天气情况
- ```Domain``` 这是我们的[领域模型](https://en.wikipedia.org/wiki/Domain_model)，它包含了领域逻辑（相对来说，在我们的示例中不甚重要）

> - ```Controller``` classes provide REST endpoints and deal with HTTP requests and responses
> - ```Repository``` classes interface with the database and take care of writing and reading data to/from persistent storage
> - ```Client``` classes talk to other APIs, in our case it fetches JSON via HTTPS from the darksky.net weather API
> - ```Domain``` classes capture our [domain model](https://en.wikipedia.org/wiki/Domain_model) including the domain logic (which, to be fair, is quite trivial in our case).

有经验的Spring开发人员可能会注意到这里缺失了一个常用的层次：受[Domain-Driven Design](https://en.wikipedia.org/wiki/Domain-driven_design)的启发，很多开发人员通常会构建一个由服务类组成的服务层。我决定不在这个应用中包含服务层。原因之一是我们的应用程序很简单，服务层只会成为一个不必要的中间层。另一个是我认为人们过度使用服务层。我经常遇到在服务类中写了全部业务逻辑的代码库。领域模型仅仅成为数据层，而不是行为（[贫血域模型](https://en.wikipedia.org/wiki/Anemic_domain_model)）。对于每一个稍有复杂度的应用来说，这浪费了很多让代码保持结构良好且易于测试的优秀方案，并且没能充分利用面向对象的威力。

> Experienced Spring developers might notice that a frequently used layer is missing here: Inspired by Domain-Driven Design a lot of developers build a service layer consisting of service classes. I decided not to include a service layer in this application. One reason is that our application is simple enough, a service layer would have been an unnecessary level of indirection. The other one is that I think people overdo it with service layers. I often encounter codebases where the entire business logic is captured within service classes. The domain model becomes merely a layer for data, not for behaviour (an Anemic Domain Model). For every non-trivial application this wastes a lot of potential to keep your code well-structured and testable and does not fully utilise the power of object orientation.

我们的repositories非常简单，它提供简单的CRUD功能。为了保持代码简单，我使用了Spring Data。 Spring Data为我们提供了一个简单而通用的CRUD实现，我们可以直接使用而不需再造轮子。它还负责为我们的测试启动一个内存数据库，而不是像生产中一样使用真正的PostgreSQL数据库。

> Our repositories are straightforward and provide simple CRUD functionality. To keep the code simple I used Spring Data. Spring Data gives us a simple and generic CRUD repository implementation that we can use instead of rolling our own. It also takes care of spinning up an in-memory database for our tests instead of using a real PostgreSQL database as it would in production.

看看代码库，熟悉一下内部结构。这将有助于我们的下一步：对应用进行测试/测试我们的应用！

> Take a look at the codebase and make yourself familiar with the internal structure. It will be useful for our next step: Testing the application!

### To be continue...


